#!/usr/bin/perl -wT

use strict;
use CGI;
use Data::Dumper;
use List::Util 'shuffle', 'min', 'max' ;
use POSIX;
use XML::Simple;

my $xml = new XML::Simple;

###########################################################
# Yes, this is sloppy. I am aware, but it's also unique.
# Unique, Ubiquitous Singletons.

our $q = CGI->new;
our $xml_data = $xml->XMLin(   "../data.xml", ForceContent => 1, ForceArray  =>[]  );
our $seed=set_seed();
srand $seed;
# This is our city object- it can and will be exported to xml eventually, so keep it clean.
our $city={'seed'=>$seed};

#TODO break out crime/law enforcement into it's own section
#imprisonment rates can range from 0.7% US to 0.1%
#TODO look into passing rand_from_array a pointer.
#TODO roads out of town
#TODO calculate children as a % of the population
#TODO calculate maturity/age of town
#TODO city wall
#TODO travelers

#########################################################################
# First thing we need to do is establish a city skeleton of information,
# then fill it in as needed by each subsection of the sample text.
#########################################################################
build_city();
print Dumper $city;
#########################################################################
# Now that $city is fleshed out, we can print it..
#########################################################################

#if (defined $q->param('type') and $q->param('type') eq 'xml' ){
#    print $q->header( 'text/xml' );
#    print "<?xml version='1.0'  encoding='ISO-8859-1' ?>\n";
#    print XMLout($city);
#}elsif (defined $q->param('type') and $q->param('type') eq 'source' ){
#    print $q->header( 'text/xml' );
#    print "<?xml version='1.0'  encoding='ISO-8859-1' ?>\n";
#    print XMLout($xml_data);
#
#}else {
#
#    print $q->header;
#    #print describe_city();
#    print describe_city();
#}
#exit;


#######################################################################################################################
#######################################################################################################################
#######################################################################################################################
#######################################################################################################################
#######################################################################################################################
#######################################################################################################################


sub build_city {
    $city={'seed'=>$seed};

    # - Generate a name
    generate_city_name();

    #select city type and population:
    generate_city_core();

    #generate govt and beliefs
    generate_city_credence();

    # generate physical traits
    generate_physical_traits();

}


###############################################################################
#
# generate_physical_traits - Generate the location, size, support area, 
# landmarks, 
# 
#
###############################################################################
sub generate_physical_traits {
    generate_location();
    generate_housing();
    generate_area();
    generate_support_area();
#    generate_districts();
#    generate_streets();
#    generate_walls();
#    generate_roads();

}

###############################################################################
#
# generate_support_area - using population size, determine the size of the
# area needed to support the city. results is in square miles.
#
###############################################################################
sub generate_support_area {
    # Population * (feet per person - sizemodifier*10 ) =total feet per population adjusted for city size
    # a good economy,education, magic and law increases production by  5+5+50+5 36%
    $city->{'supportarea'}=   int($city->{'population'}/ ( 180 + $city->{'economy'} + $city->{'education'} + ($city->{'magic'}+5)*5 +$city->{'order'})*100)/100;

}


###############################################################################
#
# generate_area - using population size and density, determine the size of 
# the city. results is in hectares.
#
###############################################################################
sub generate_area {
    # Population * (feet per person - sizemodifier*10 ) =total feet per population adjusted for city size
    $city->{'area'}=   int( $city->{'population'}*( $city->{'popdensity'}->{'feetpercapita'}-$city->{'size_modifier'}*10   ) /107639*100 )/100; #hectares;

}

###############################################################################
#
# generate_housing - generate the types of housing and how much there is.
#
###############################################################################
sub generate_housing {
    $city->{'housing'}={};

    my @qualitylist= keys %{ $xml_data->{'housing'}->{'quality'}};

    foreach my $housingquality ( @qualitylist ){

        my $housingtype= $xml_data->{'housing'}->{'quality'}->{$housingquality};

        # fractional housecount total, but you can't have .3 of a house...        
        my $housecount= $city->{'population'}  *   $housingtype->{'percent'}/$housingtype->{'density'}/100;

        # to ensure minimal housing, we require poor housing via ceil, so we always have 1.
        if (defined $housingtype->{'required'}){
            $city->{'housing'}->{$housingquality}        = ceil ($housecount); # ceil used because we want at least 1 poor house
        }else{
            $city->{'housing'}->{$housingquality}        = floor ($housecount);
        }
        $city->{'housing'}->{'total'}+=$city->{'housing'}->{$housingquality}

    }


    # Calculate abandoned by finding 10% of total and adjusting it by economy conditions (+/-5%)
    $city->{'housing'}->{'abandoned'}   = floor($city->{'housing'}->{'total'} *(10-$city->{'economy'} )/100 );

}


###############################################################################
#
# generate_location - select the location we wish to use and any landmarks.
#
###############################################################################


sub generate_location {
    $city->{'location'} = { 'landmarks'=>[]  };
    my $locationlist=$xml_data->{'locations'}->{'location'};

    my $location = rand_from_array( @{ $locationlist } );
    $city->{'location'}->{'name'}=$location->{'description'};
    $city->{'location'}->{'port'}= ( &d(100) <= $location->{'port_chance'}  );

    foreach my $landmark (shuffle @{$location->{'landmarks'}}){
        if (&d(100) <= $landmark->{'chance'}){
            push @{$city->{'location'}->{'landmarks'}},  $landmark->{'content'};
        }
    }
}




###############################################################################
#
# generate_city_credence - select government, ethics, tolerance, etc.
#
###############################################################################
sub generate_city_credence{


    # - Generate ethics
    generate_city_ethics();

    # - Generate beliefs
    generate_city_beliefs();

    # - set govt type
    set_govt_type();

    # - generate laws
    set_laws();

    #generate imprisonment rate
    generate_imprisonment_rate();
}

###############################################################################
#
# generate_imprisonment_rate - city size, authority, order and education
# determine what percentage of the city is in jail. 0.05% to  01.815%
#
###############################################################################

sub generate_imprisonment_rate{
    # should range from ((15-5-5-5)*.5/5+1).5/10=.05% to ((15+5+5+12)*1.5/5+1)/10=1.815
    # high authority means more in jail
    # low education means more in jail
    # larger city means more in jail
    # higher order means more in jail
    $city->{'imprisonment'}={};
    $city->{'imprisonment'}->{'percent'} = (((15 + $city->{'authority'} - $city->{'education'}  +$city->{'size_modifier'} )/5) +1 )*($city->{'order'}+50)/100 /10 ;

    #calculate out the actual prison population in whole numbers
    $city->{'imprisonment'}->{'population'}= ceil( $city->{'imprisonment'}->{'percent'}/100 * $city->{'population'});

    #recalulate to make the percent accurate with the population
    $city->{'imprisonment'}->{'percent'}= int($city->{'imprisonment'}->{'population'}/$city->{'population'}*1000)/10;


}


###############################################################################
#
# generate_city_core - select the size, type, population, races and population
# breakdown. This is the core of the city stats, everything else is icing.
#
###############################################################################
sub generate_city_core{
    # - Generate a size
    set_city_size();

    # - Generate a type
    set_city_type();

    # - Generate a pop_type
    generate_pop_type();

    # - Generate assign races
    assign_races();

    # - Generate pop counts
    generate_pop_counts();

    # - generate city age
    generate_city_age();
    
    # - generate children %
    generate_children();
}



###############################################################################
#
# generate_children - set the percentage of the population that are children, 
# modified by the age of the city
#
###############################################################################
sub generate_children {

    $city->{'children'}={};
    #calculate the pop based on 20 +random factor + city age modifier; should give us a rage between
    # 10% and 45%, which follows the reported international rates of the US census bureau, so STFU.
    $city->{'children'}->{'percent'}= 20 + &d(15) +  $city->{'cityage'}->{'agemod'};

    #calculate out the actual child population in whole numbers
    $city->{'children'}->{'population'}= floor( $city->{'children'}->{'percent'}/100 * $city->{'population'});

    #recalulate to make the percent accurate with the population
    $city->{'children'}->{'percent'}= int($city->{'children'}->{'population'}/$city->{'population'}*1000)/10;

}


###############################################################################
#
# generate_city_age - a simple selector
#
###############################################################################
sub generate_city_age {
    my $agelist=$xml_data->{'cityages'}->{'cityage'};

    $city->{'cityage'}= rand_from_array( @{ $agelist } );
}


###############################################################################
#
# Generate Secondary Power - select a plot, a power and a subplot.
#
###############################################################################
sub generate_secondary_power {
    $city->{'secondarypower'}={};

    # select a plot
    my $plotlist=$xml_data->{'secondarypower'}->{'plot'};
    $city->{'secondarypower'}->{'plot'} = rand_from_array( @{ $plotlist } )->{'content'};

    #select a power and a related subplot.
    my $powerlist=$xml_data->{'secondarypower'}->{'power'} ;
    my $power = rand_from_array( @{ $powerlist} );
    $city->{'secondarypower'}->{'power'} = rand_from_array( @{ $powerlist} )->{'type'};
    $city->{'secondarypower'}->{'subplot'} = rand_from_array( @{ $power->{'subplot'} } )->{'content'};
}


###############################################################################
#
# set_govt_type - fairly simple; select a type of govt from the list.
#
###############################################################################
sub set_govt_type {
    my $govttypelist=$xml_data->{'govtypes'}->{'govt'} ;
    $city->{'govtype'} = rand_from_array( @{ $govttypelist } );

    my $descriptorlist=$xml_data->{'govtypes'}->{'descriptor'} ;
    my $descriptor = rand_from_array( @{ $descriptorlist } );
    $city->{'govtype'}->{'descriptor'}=$descriptor->{'content'};

    # add random element + govtype base approvalmod + descriptor approval + authority mod
    $city->{'govtype'}->{'approvalmod'}    = &d(4)-2 +  $city->{'govtype'}->{'approvalmod'} + $descriptor->{'approvalmod'} +  $city->{'authority'};

    # ensure it falls in the proper range
    $city->{'govtype'}->{'approvalmod'}=max(-5, min(5,  $city->{'govtype'}->{'approvalmod'}   ) );

    $city->{'govtype'}->{'religion'}=&d(4)-2 +  $city->{'govtype'}->{'religion'} ; 

}



###############################################################################
#
# Set Laws - Laws have three facets- enforcement, trial and punishment. 
# Select these from arrays.
#
###############################################################################

sub set_laws {
    $city->{'laws'} = {};
    for my $facet (qw( enforcement trial punishment )) {
        my $facetlist=$xml_data->{'laws'}->{$facet}->{'option'};
        $city->{'laws'}->{$facet} = rand_from_array( @{ $facetlist } )->{'content'};
    }
}



###############################################################################
#
# generate_city_ethics - Intended for morals and order (classic alignment).
#
###############################################################################
sub generate_city_ethics {
    $city->{'moral'} = &d(100);
    $city->{'order'} = &d(100);

    # adjust all modifiers for each race
    for my $race ( @{ $city->{'races'} } ) {
        $city->{'moral'} += $race->{'moral'};
        $city->{'order'} += $race->{'order'};
    }

    # Use min/max to ensure that we fall in the proper ranges when all is said and done        
    $city->{'moral'}=max(1, min(100, $city->{'moral'} ) );
    $city->{'order'}=max(1, min(100, $city->{'order'} ) );

}
###############################################################################
#
# generate_city_beliefs - This includes other scales, such as determining if 
# the city is a trade hub, etc. 
#
###############################################################################
sub generate_city_beliefs {

    # set the baseline random modifier
    foreach my $scale (qw/ magic authority economy education travel tolerance/ ){
        $city->{$scale}    =&d(4)-2;
    }

    # adjust all modifiers for each race
    for my $race ( @{ $city->{'races'} } ) {
        foreach my $scale (qw/ magic authority economy education travel tolerance/ ){
            $city->{$scale} += $race->{$scale};
        }
    }

    # Use min/max to ensure that we fall in the proper ranges when all is said and done        
    foreach my $scale (qw/ magic authority economy education travel tolerance/ ){
        $city->{$scale}=max(-5, min(5, $city->{$scale} ) );
    }

}

###############################################################################
#
# generate_population_counts - for each race percentage. After getting 
# population counts, recalulate total population, then final percentages.
# note that actual races are not yet associated.
#
###############################################################################
sub generate_pop_counts {
    my $population = $city->{'population'};
    my $newpop     = 0;
    my @races;
    my @newraces;

    # Loop through each race percentage, and get a rough count based
    # on population total
    for my $race ( sort @{ $city->{'races'} } ) {
        $race->{'count'} = ceil( $population * $race->{'percent'} / 100 );
        $newpop += $race->{'count'};
        push @races, $race;
    }

    # Add up all of the rough counts to create a final population total
    $city->{'population'} = $newpop;
    $city->{'races'}      = \@races;

    # Loop through the races a second time, recalulating percentages.
    for my $race ( sort @{ $city->{'races'} } ) {
        $race->{'percent'} = int( $race->{'count'} / $newpop * 1000 ) / 10;
        push @newraces, $race;
    }
    $city->{'races'} = \@newraces;
}


###############################################################################
#
# Assign races. This consists of 
#   * looking at the base population type to gather available base races 
#   * looping through the race percentages and assigning an available race
#   * adding an "off race" if applicable.
#   * adding 1% other    
#
###############################################################################
sub assign_races {
    my $base_pop        = $city->{'base_pop'};
    my @races;


    # Get all of the available race options
    my @available_races = get_races($base_pop);

    # for each race percentage on the city,
    # add assign a race and add it to the list.
    for my $racepercentage ( @{ $city->{'races'} } ) {
        my $newrace = pop(@available_races);
        push @races, add_race_features( $racepercentage, $newrace );
    }


    # If the base_pop has an "off" race, add it.
    if ( $city->{'add_other'} eq 'true' ) {
        my $newrace              = get_other_race($base_pop);
        my $replace_race_id      = &d( scalar @races ) - 1;
        $races[$replace_race_id] = add_race_features( $races[$replace_race_id], $newrace );
    }

    # add the last percent of "others" because mrsassypants didn't grok that
    # things added up to 99% for a reason.
    push @races,add_race_features( {'percent'=>'1'}, get_races('other'));


    #replace race percentages with full race breakdowns.
    $city->{'races'} = \@races;
}


###############################################################################
#
# add_race_features - copy the features over for a given races. Effectively
# merges percent onto the race.
#
###############################################################################

sub add_race_features {
    my ( $race, $newrace ) = @_;
    $race->{'name'}      = $newrace->{'content'};
    $race->{'order'}     = $newrace->{'order'};
    $race->{'moral'}     = $newrace->{'moral'};
    $race->{'magic'}     = $newrace->{'magic'};
    $race->{'authority'} = $newrace->{'auth'};
    $race->{'economy'}   = $newrace->{'econ'};
    $race->{'education'} = $newrace->{'edu'};
    $race->{'travel'}    = $newrace->{'travel'};
    $race->{'tolerance'}    = $newrace->{'toler'};
    $race->{'type'}      = $newrace->{'type'};

    if (defined $race->{'dominant'} ){
        $city->{'dominant_race'}  =  $newrace->{'content'};
    }
    return $race;
}



###############################################################################
#
# get races - get the races that match the given population type.
# If the type is mixed, add the race as long as it's not an other race.
#
###############################################################################

sub get_races {
    my ( $type ) = @_;
    my @races;
    for my $race ( @{ $xml_data->{'races'}->{'race'} } ) {
        if (   ($race->{'type'} eq $type)  or   (($type eq 'mixed') and  ($race->{'type'} ne 'other')) ) {
            push @races, $race;
        }
    }
    return shuffle @races;
} 

###############################################################################
#
# get_other_race - get the races that doesn't match the given population type.
# make sure to exclude other.
#
###############################################################################

sub get_other_race {
    my ($type) = @_;
    my @races;
    for my $race ( shuffle @{ $xml_data->{'races'}->{'race'} } ) {
        if ( $race->{'type'} ne $type  and   ($race->{'type'} ne 'other') ) {
            return $race;
        }
    }
} 

###############################################################################
#
# Generate a Population Type, then populate the population type, population 
# density, and a list of unassigned race percentages.
#
###############################################################################
sub generate_pop_type {
    my $poptype     = roll_from_array( &d(100), $xml_data->{'poptypes'}->{'population'} );
    my $popdensity  = rand_from_array( @{$xml_data->{'popdensity'}->{'option'} });

    $city->{'popdensity'}   = $popdensity;
    $city->{'poptype'}      = $poptype->{'type'};
    $city->{'races'}        = $poptype->{'option'};
}



###############################################################################
#
# generate_city_name - This consists of the pre,
# the root, the post and the trailer.
#
###############################################################################
sub generate_city_name {
    my $nameobject = parse_object($xml_data->{'cityname'});
    $city->{'nameobj'} = $nameobject;
    $city->{'name'}="";

    if (defined $nameobject->{'pre'}){
        $city->{'name'}=$nameobject->{'pre'}." ";
    }

    $city->{'name'}.=$nameobject->{'root'}.$nameobject->{'post'};

    if (defined $nameobject->{'trailer'}){
        $city->{'name'}.=" ".$nameobject->{'trailer'};
    }

}


###############################################################################
#
# set_city_type - Find the type of city by selecting it from the citytype list,
# Then populate the base population, type, description and whether 
# or not it's a mixed city.
#
###############################################################################
sub set_city_type {
    my $citytypelist=$xml_data->{'citytype'}->{'city'};
    my $citytype = roll_from_array( &d(100), $citytypelist );

    $city->{'base_pop'}    = $citytype->{'base_pop'};
    $city->{'type'}        = $citytype->{'type'};
    $city->{'description'} = $citytype->{'content'};
    $city->{'add_other'}   = $citytype->{'add_other'};
}


###############################################################################
#
# set_city_size - Find the size of the city by selecting from the citysize 
# list, then populate the size, gp limit, population, and size modifier.
#
###############################################################################
sub set_city_size {
    my $citysizelist=$xml_data->{'citysize'}->{'city'} ;
    my $citysize = roll_from_array( &d(100), $citysizelist );

    $city->{'size'}          = $citysize->{'size'};
    $city->{'gplimit'}       = $citysize->{'gplimit'};
    $city->{'population'}    = $citysize->{'minpop'} + &d( $citysize->{'maxpop'} - $citysize->{'minpop'} );
    $city->{'size_modifier'} = $citysize->{'size_modifier'};
}

#######################################################################################################################
################                                                                                       ################
################                            These are more generic functions                           ################
################                                                                                       ################
#######################################################################################################################
#######################################################################################################################
#######################################################################################################################
#######################################################################################################################


###############################################################################
#
# set_seed - check the parameters for cityID and set the seed accordingly.
# This is what allows us to return to previously generated hosts.
#
###############################################################################
sub set_seed{
    if (defined $q->param('cityid') and  $q->param('cityid')=~/(\d+)/){
        return $1;
    }else{
        return int rand(1000000);
    }
}


###############################################################################
#
# rand_from_array - select a random item from an array.
#
###############################################################################
sub rand_from_array {
    my (@array) = @_;
    my $index = int( rand( scalar @array ) );
    return $array[$index];
}

###############################################################################
#
# roll_from_array - When passed a roll and a list of items, check the
# min and max properties of each and select the one that $roll best fits
# otherwise use the first item.
# 
###############################################################################
sub roll_from_array {
    my ( $roll, $items ) = @_;
    my $selected_item = $items->[0];
    for my $item (@$items) {
        if ( $item->{'min'} <= $roll and $item->{'max'} >= $roll ) {
            $selected_item = $item;
            last;
        }
    }
    return $selected_item;
}

###############################################################################
#
# d - this serves the function of rolling a dice- a d6, d10, etc.
#
###############################################################################
sub d {
    my ($die) = @_;
    # d as in 1d6
    return int( rand($die) );
}

#####################################################
#
# Parse Object - a horribly named subroutine to parse
# out and randomly select the parts.
#
#####################################################
sub parse_object {
    my ($object)=@_;
    my $newobj= { 'list'=>[]};
    # We currently only care about 4 parts
    foreach my $part (qw/ pre root post trailer/){

        # Make sure that the part exists for this object.
        if(defined $object->{$part}){

            # If the object is an array, we're going to shuffle
            # the array and select one of the elements.
            if ( ref($object->{$part}) eq 'ARRAY'){
                # Shuffle the array and pop one element off
                my @parts=shuffle( @{$object->{$part}});
                my $newpart=pop(@parts);

                # make sure the element has content;
                # ignore it if it doesn't.
                if (defined $newpart->{'content'}){
                    # If no chance is defined, add it to the list.
                    if (!defined $object->{$part.'_chance'}){
                        push @{$newobj->{'list'}}, $newpart->{'content'};
                        $newobj->{$part}=$newpart->{'content'};

                    # If chance is defined, compare it to
                    # the roll, and add it to the list.
                    } elsif(defined $object->{$part.'_chance'} and &d(100) <= $object->{$part.'_chance'} ) {
                        push @{$newobj->{'list'}}, $newpart->{'content'};
                        $newobj->{$part}=$newpart->{'content'};
                    }
                }
            # If the object is a Hash, we presume that there's only one choice
            } elsif ( ref($object->{$part}) eq 'HASH'  and $object->{$part}->{'content'}){

                # rename for easier handling
                my $newpart=$object->{$part};

                # If no chance is defined, add it to the list.
                if (!defined $object->{$part.'_chance'}){
                    push @{$newobj->{'list'}}, $newpart->{'content'};
                    $newobj->{$part}=$newpart->{'content'};

                # If chance is defined, compare it to
                # the roll, and add it to the list.
                } elsif(defined $object->{$part.'_chance'} and &d(100) <= $object->{$part.'_chance'} ) {
                    push @{$newobj->{'list'}}, $newpart->{'content'};
                    $newobj->{$part}=$newpart->{'content'};
                }
            }
        }
    }
    $newobj->{'content'}=join " ", @{$newobj->{'list'}};
    delete $newobj->{'list'};
    # return the slimmed down version
    return $newobj;
}



