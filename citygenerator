#!/usr/bin/perl -wT

use strict;
use CGI;
use Data::Dumper;
use List::Util 'shuffle', 'min', 'max' ;
use POSIX;
use XML::Simple;

my $xml = new XML::Simple;

###########################################################
# Yes, this is sloppy. I am aware, but it's also unique.
# Unique, Ubiquitous Singletons.







our $q = CGI->new;
our $xml_data = $xml->XMLin(   "../data.xml", ForceContent => 1, ForceArray  =>[]  );
our $seed=set_seed();
srand $seed;
# This is our city object- it can and will be exported to xml eventually, so keep it clean.
our $city={'seed'=>$seed};
#TODO travelers


#########################################################################
# First thing we need to do is establish a city skeleton of information,
# then fill it in as needed by each subsection of the sample text.
#########################################################################
build_city();
#########################################################################
# Now that $city is fleshed out, we can print it..
#########################################################################

if (defined $q->param('type') and $q->param('type') eq 'xml' ){
    print $q->header( 'text/xml' );
    print "<?xml version='1.0'  encoding='ISO-8859-1' ?>\n";
    print XMLout($city);
}elsif (defined $q->param('type') and $q->param('type') eq 'dump' ){
    print $q->header( 'text/plain' );
    print Dumper $city;
}elsif (defined $q->param('type') and $q->param('type') eq 'source' ){
    print $q->header( 'text/xml' );
    print "<?xml version='1.0'  encoding='ISO-8859-1' ?>\n";
    print XMLout($xml_data);

}else {

    print $q->header;
    #print describe_city();
    print describe_city();
}
exit;


#######################################################################################################################
#######################################################################################################################
#######################################################################################################################
#######################################################################################################################
#######################################################################################################################
#######################################################################################################################

sub describe_city {
  my $style=print_style(); 
  my $content="        <!DOCTYPE html> 
        <html>
            <head>
                <title>City Generator: $city->{'name'} </title>
            </head>
            $style
            <body>
";
  $content.=describe_summary();
  $content.=describe_geography();
  $content.=describe_cityscape();
  $content.=describe_government();

}
#print <<EOF
sub describe_secondarypower{
    my $content=" Within the city, there is ".$city->{'secondarypower'}->{'power'}. " that ".$city->{'secondarypower'}->{'plot'}." current leadership";
    if(defined $city->{'secondarypower'}->{'subplot'} ){
        $content.=" while secretly ".$city->{'secondarypower'}->{'subplot'};
    }
    return $content.".";
}
sub describe_approval{
    if ($city->{'govtype'}->{'approvalmod'} <-1){
        return "does not approve of"
    }elsif ($city->{'govtype'}->{'approvalmod'} >1){
        return "approves of"
    }else{
        return "is indifferent towards"
    }
}
sub describe_freedom{
    if ($city->{'govtype'}->{'religion'} <-1){
        return "oppressed"
    }elsif ($city->{'govtype'}->{'religion'} >1){
        return "welcomed"
    }else{
        return "neither oppressed nor supported"
    }
}
sub describe_magic{
    if ($city->{'magic'} <-1){
        return "verboten."
    }elsif ($city->{'magic'} >1){
        return "legal and common"
    }else{
        return "looked upon with suspicion"
    }
}
sub describe_relations {
    my @relations;
#print Dumper $city->{'neighbors'} ; 
    foreach my $neighbor (  @{$city->{'neighbors'}}  ){
        push @relations, $neighbor->{'relation'}." ".$neighbor->{'name'};
    }
    return "<ul><li>".join('</li><li>',@relations)."</li></ul>";
}
sub describe_government{
    my $secondarypower=describe_secondarypower();
    my $approval=describe_approval();
    my $freedom=describe_freedom();
    my $magic=describe_magic();
    my $relations=describe_relations();
    my $content="
                    <section>
                        <h2>Government</h2>
                        <p>$city->{'name'} is ruled by $city->{'govtype'}->{'descriptor'} $city->{'govtype'}->{'content'}.$secondarypower The population $approval $city->{'govtype'}->{'content'} in general. Freedom of religion is $freedom, and magic use is $magic. </p>;

                        <h3>Diplomatic Ties</h3>
                        <p>$city->{'name'} has the following diplomatic relations:</p>
                        $relations

                    </section>
";


}


sub describe_summary {
    if ($city->{'dominant_race'}){$city->{'dominant_race'}=", which is overwhelmingly ".$city->{'dominant_race'}; }else{$city->{'dominant_race'}=""}
    my $content="
                    <header>
                        <a href='?cityid=$city->{'seed'}'><h1> $city->{'name'} ($city->{'seed'})</h1></a>
                        <sub><a href='?cityid=$city->{'seed'}&type=xml'>xml version</a>    <a href='?cityid=$city->{'seed'}&type=source'>source data</a>  </sub>
                        <h2>Summary</h2>
                        <p><b>$city->{'name'}</b> is a $city->{'economydescription'}, $city->{'description'} of around $city->{'population'}$city->{'dominant_race'}.</p>
                    </header>";
}
sub describe_geography {
    my $landmarks= print_landmarks();
    my $neighbors= print_neighbors();
    my $port= ( $city->{'location'}->{'port'} ) ? ' and is a port town' : '';
    my $content="
                    <section>
                        <h2>Geography</h2>
                        <p>This $city->{'poptype'} $city->{'size'} is located $city->{'location'}->{'name'}$port. The $city->{'popdensity'}->{'type'} populated town proper is $city->{'area'} hectares, and is supported by a $city->{'supportarea'} square mile region. $landmarks The surrounding region is $city->{'topography'}. $neighbors

                    </section>
";
}
sub describe_port {
    if   ( $city->{'location'}->{'port'} ){
        return " There is a port on the ".$city->{'location'}->{'portdirection'}." side of the city.";
    }

}
sub describe_walls {
    if   ( $city->{'walls'}->{'content'} eq 'none'){
        return " No walls currently surround the city."
    }else{
        return " Visitors are greeted with a ".$city->{'walls'}->{'content'}. " that is ".$city->{'walls'}->{'height'}." feet tall.";
    }
    
}
sub describe_roads {
    return " The city is lined with ". $city->{'streets'}->{ 'content'}.".";
}
sub describe_districts {
    my $content="
                <h3>Districts</h3>";
    if (scalar(@{ $city->{'districts'}})>0){
         $content.="                   The city contains the following Districts:";
        return $content."<ul><li>".join('</li><li>',@{ $city->{'districts'}})."</li></ul>";
    }else{
        return $content."The city contains no districts.";
    }
}
sub describe_housing {
    my @housing;
    foreach my $key (keys %{$city->{'housing'}}){
        if ($key ne "total"){
            push @housing, "$key: ".$city->{'housing'}->{$key};
        }
    }
    return "<ul><li>".join('</li><li>',@housing)."</li></ul> <p>Total: $city->{'housing'}->{'total'} homes";
}
sub describe_businesses {
    my @businesses;
    #return Dumper $city->{'business'};
    foreach my $key (sort keys %{$city->{'business'}}){
        my $business=$city->{'business'}->{$key};
        push @businesses, $business->{'count'}." ".$key." ($business->{'specialists'} specialists)";
    }
    return "<ul><li>".join('</li><li>',@businesses)."</li></ul>";
}
sub describe_cityscape {
    my $port=describe_port();
    my $walls=describe_walls();
    my $roads=describe_roads();
    my $districts=describe_districts();
    my $housing=describe_housing();
    my $businesses=describe_businesses();
     $city->{'streets'}->{'mainroads'} = $city->{'streets'}->{'mainroads'} == 0 ? "none": $city->{'streets'}->{'mainroads'};
     $city->{'streets'}->{'mainroads'} = $city->{'streets'}->{'mainroads'} == 1 ? "1 is": $city->{'streets'}->{'roads'}." are";
     $city->{'streets'}->{'roads'} = $city->{'streets'}->{'roads'} == 1 ? "is 1 road": "are ".$city->{'streets'}->{'roads'}." roads";
    my $content="
                    <section>
                        <h2>Cityscape</h2>
                        <p>There $city->{'streets'}->{'roads'} leading to $city->{'name'}; $city->{'streets'}->{'mainroads'} major.$port$walls$roads</p>
                        $districts
                        <h3>Housing</h3>
                            The city contains the following housing:$housing
                        <h3>Businesses</h3>
                            You can find the following businesses:$businesses
                    </section>
";
}

###############################################################################
#
# print_neighbors - return the neighbors in an easy-to-display sentence.
#
###############################################################################
sub print_neighbors {
#    print "$seed\n";
    my $neighbors=$city->{'neighbors'};
    if(ref($neighbors) eq 'ARRAY'){
        if (scalar(@$neighbors) eq 1 ){
            return "<a href='?cityid=$neighbors->[0]->{'id'}'> $neighbors->[0]->{'name'}</a> is a neighbor. ";
        
        }elsif(scalar(@$neighbors) >1 ){
       #     print Dumper @$neighbors;
            my @neighborlist=@$neighbors;
            my $lastneighbor=pop(@neighborlist);
            my $content="Neighboring cities include ";
            foreach my $neighbor (@neighborlist){
                $content.="<a href='?cityid=$neighbor->{'id'}'> $neighbor->{'name'}</a>, ";
            }
            $content.=" and <a href='?cityid=$lastneighbor->{'id'}'> $lastneighbor->{'name'}</a>. ";

            return $content; 
        }else{
            return "";
        }
    }
}
###############################################################################
#
# print_landmarks - return the landmarks in an easy-to-display sentence.
#
###############################################################################
sub print_landmarks {
    my $landmarks=$city->{'location'}->{'landmarks'};
#    print Dumper $city->{'location'} ;
    if(ref($landmarks) eq 'ARRAY'){
        if (scalar(@$landmarks) eq 1 ){
            return "A nearby ".$landmarks->[0]." is a local landmark.";
        
        }elsif(scalar(@$landmarks) >1 ){
#            @$landmarks=map {$_->{'content'}}  @$landmarks;
#            print Dumper @$landmarks;
            my $landmarklist=" and ".(pop(@{$landmarks}));
            return "Local landmarks include a ".join(', ', @{$landmarks}) . $landmarklist .".";
        }else{
            return "";
        }
    }
}


#Population
#The population is broken down as follows:
#
#    1848 Troglodyte ( 98.9%)
#    19 Mindflayer ( 1%)
#____ [and ______] are treated as equals by _______. ______ looks down upon ________. There has been no history of racial violence. 20% of the trogladyte population belong to a violent religious sect.
#
#
#Economy:
#The economy is strong. Magic is somewhat common. Education is low. This is an economically isolated area with few travelers.
#
#Galeshead Ridge is known for:
#
#    nearby bays
#    crucial bauxite deposits
#
#
#
#--------------------------------------------
#Local Info
#
#Within the city and the surrounding areas, you'll find:
#
#    Thieves guild (secret)
#    Adventurers guild (secret)
#
#Current Events
#
#You arrive at the city around mid-day, The the clouds are overcast, the air is thin and the wind is heavy. It is unusually hot. There is thunder and lighting.
#
#Upon arrival, around 38 citizens are wandering the chilly town. You see:
#
#    the aftermath of a war
#    the midst of a raid
#
#
#
#EOF
#;






###############################################################################
#
# print_style - a simple style to make lists pretty.
#
###############################################################################
sub print_style{

    return "
        <style type='text/css'>
            body{
                background-color:#44aa44;
                width:800px;
                padding:5px;
                margin:auto;
            }
            ul{   
                -moz-column-width:222px;
                -webkit-column-width:222px ;
            } 
        </style>\n";
}




#######################################################################################################################
#######################################################################################################################
#######################################################################################################################
#######################################################################################################################
#######################################################################################################################
#######################################################################################################################







sub build_city {
    $city={'seed'=>$seed};

    # - Generate a name
    $city->{'name'}=generate_city_name();

    #select city type and population:
    generate_city_core();

    #generate govt and beliefs
    generate_city_credence();

    # generate physical traits
    generate_physical_traits();

    generate_economics();

}

###############################################################################
#
# generate_economics - generate various markets, organizations and resources
#
###############################################################################
sub generate_economics {
    generate_markets();
    generate_resources();
    generate_taverns();
    generate_travelers();
    generate_economic_description();
}

###############################################################################
#
# generate_travelers - generate a few travelers
#
###############################################################################
sub generate_economic_description {
    my $econtype     = roll_from_array( $city->{'economy'}, $xml_data->{'economy'}->{'option'} );
    my $adjective     = rand_from_array( $econtype->{'adjective'} )->{'content'};
    $city->{'economydescription'}=$adjective;
}

###############################################################################
#
# generate_travelers - generate a few travelers
#
###############################################################################
sub generate_travelers{
    my $travelercount= int( ( 7 +  $city->{'size_modifier'} )/2);
    $city->{'travelers'}=[];
    while ($travelercount-- ){
        #TODO switch to roll_from_array
        my $travelerclass= rand_from_array( [ keys %{$xml_data->{'classes'}->{'class'}}] );
        my $traveler=$xml_data->{'classes'}->{'class'}->{$travelerclass};
        $traveler->{'class'}=$travelerclass;
        $traveler->{'level'}= min( 20 ,max(1, &d($traveler->{'max_level'}) + &d( $city->{'size_modifier'} )) ) ;
    
        push @{$city->{'travelers'}}, $traveler;

    }

}

###############################################################################
#
# generate_taverns - generate a few taverns;
#
###############################################################################

sub generate_taverns{
    my $taverncount=0;
    if (defined $city->{'business'}->{'tavern'}){
        $taverncount+=$city->{'business'}->{'tavern'}->{'count'};
    }
    if (defined $city->{'business'}->{'tavern/inn'}){
        $taverncount+=$city->{'business'}->{'tavern/inn'}->{'count'};
    }
    $taverncount=max(5,  $taverncount);
    $city->{'taverns'}=[];
    while ($taverncount-- > 0){
        my $tavern->{'name'}= parse_object($xml_data->{'taverns'} )->{'content'};
        $tavern->{'cost'}=$city->{'economy'};
        $tavern->{'population'}=0;

        $tavern->{'size'}=rand_from_array( $xml_data->{'taverns'}->{'size'}   );
        $tavern->{'cost'}+=$tavern->{'size'}->{'cost_mod'};
        $tavern->{'population'}+=$tavern->{'size'}->{'pop_mod'};
        $tavern->{'size'}=$tavern->{'size'}->{'content'};

        $tavern->{'condition'}=rand_from_array( $xml_data->{'taverns'}->{'condition'}   );
        $tavern->{'cost'}+=$tavern->{'condition'}->{'cost_mod'};
        $tavern->{'condition'}=$tavern->{'condition'}->{'content'};

        $tavern->{'class'}=rand_from_array( $xml_data->{'taverns'}->{'class'}   );
        $tavern->{'cost'}+=$tavern->{'class'}->{'cost_mod'};
        $tavern->{'class'}=$tavern->{'class'}->{'content'};

        $tavern->{'violence'}=rand_from_array( $xml_data->{'taverns'}->{'violence'}   )->{'content'};
        $tavern->{'legal'}=rand_from_array( $xml_data->{'taverns'}->{'legal'}   )->{'content'};

        $tavern->{'bartender'}=generate_bartender();

        push @{$city->{'taverns'}}, $tavern;
    }

}

###############################################################################
#
# generate_bartender - generate a bartender
#
###############################################################################
sub generate_bartender{

    my $bartender;
    $bartender->{'behavior'}=rand_from_array( $xml_data->{'behavioraltraits'}->{'trait'} )->{'type'};
    my @races=get_races(   $city->{'base_pop'}    );
    $bartender->{'race'}= pop(@races)->{'content'} ;
    $bartender->{'level'}= min( 20 ,max(1, &d("3d4")+ &d( $city->{'size_modifier'} )) ) ;

    return $bartender;


}

###############################################################################
#
# generate_resources - select resources modified by city size.
#
###############################################################################

sub generate_resources{
    #ensure that the resource count is at most 10 and at least 0
    my $resource_count=min( max($city->{'size_modifier'}+$city->{'economy'}, 0),10) ;

    #shift from 0-10 to 2-12
    $resource_count = int( rand( $resource_count ))+2;

    $city->{'resources'}=[];
    while ($resource_count-- > 0 ){
        my $resource=rand_from_array($xml_data->{'resources'}->{'resource'});
        push @{ $city->{'resources'} }, parse_object($resource);
    }

}


###############################################################################
#
# generate_markets - select some markets according to their chance of 
# appearance modified by city size.
#
###############################################################################
sub generate_markets {

    $city->{'markets'}=[];

    # minimum of 2 markets, max of size modifier(9)
    my $marketcount= max(2, &d( int(7 + $city->{'size_modifier'})/2     ));


    # loop through the marketcount to randomly select markets
    # this allows us to get "duplicates""
    while ( $marketcount > 0 ){

        # get a shuffled list of markets
        my @markets=shuffle @{ $xml_data->{'markets'}->{'option'} };

        #pop a single market off
        my $market = pop  @markets ;

        # modify the chance of the market by the size modifier
        my $chance_of_market= $market->{'chance'} +  $city->{'size_modifier'};

        # if we succeed, decrement the marketcount and push the market to 
        # our queue
        if (&d(100) <= $chance_of_market){
            $marketcount--;
            my $newmarket={ 
                                'type'=> $market->{'type'}, 
                                'name'=> $market->{'marketname'}.' '.$market->{'type'}
                            };
            # set market secret
            if ( &d(100) <$market->{'secret'} ){
                $newmarket->{'secret'}='(secret)';
            }else{
                $newmarket->{'secret'}='';
            }

            # select market detail
            if ( &d(100) > 50 ){
                my $marketoption=rand_from_array($market->{'option'});
                $newmarket->{'name'}= $marketoption->{'content'}.' '.$newmarket->{'name'};
            }

            # push it to the queue
            push @{$city->{'markets'}}, $newmarket;

       } 

    }

}








###############################################################################
#
# generate_physical_traits - Generate the location, size, support area, 
# landmarks, 
#
###############################################################################
sub generate_physical_traits {
    generate_location();
    generate_housing();
    generate_area();
    generate_support_area();
    generate_businesses();
    generate_districts();
    generate_streets();
    generate_walls();
    generate_neighbors();
    generate_topography();
}

###############################################################################
#
# generate_topography - Determine information about the neighbors. 
#
###############################################################################
sub generate_topography {
    $city->{'topography'}=rand_from_array($xml_data->{'topography'}->{'region'})->{'content'};
}

###############################################################################
#
# generate_neighbors - Determine information about the neighbors. 
#
###############################################################################
sub generate_neighbors {
    my $neighbortotal=1+&d(3);
    $city->{'neighbors'}=[];
    my $neighborcount=-int($neighbortotal/2)-1;
    while($neighborcount< ceil($neighbortotal/2)+1){
        my $newseed=$seed+$neighborcount ;
        if ($newseed != $seed){
            srand( $newseed );
            my $neighbor->{'id'}=($newseed   );
            $neighbor->{'name'}=generate_city_name();
            $neighbor->{'relation'} = rand_from_array(  $xml_data->{'neighbor'}->{'relation'}  )->{'content'};
            push @{$city->{'neighbors'}}, $neighbor;
        }
        $neighborcount++;
    }
}


###############################################################################
#
# generate_walls - Determine information about the streets. 
#
###############################################################################
sub generate_walls {
    my $roll=&d(20)+ $city->{'size_modifier'} ;
    if( $xml_data->{'walls'}->{'chance'}< $roll){
        $city->{'walls'}=parse_object($xml_data->{'walls'});
        $city->{'walls'}->{'height'}= 8 +&d(10) + $city->{'size_modifier'};
    }else{
        $city->{'walls'}->{'content'}="none";
        $city->{'walls'}->{'height'}=0;
    }
}

###############################################################################
#
# generate_streets - Determine information about the streets. 
#
###############################################################################
sub generate_streets {
    $city->{'streets'}=parse_object($xml_data->{'streets'});

    $city->{'streets'}->{'mainroads'}=max(0,   int(($city->{'travel'}+$city->{'economy'})/3)  );
    $city->{'streets'}->{'roads'}=max(1,   int(($city->{'travel'}+$city->{'economy'})/3) + $city->{'streets'}->{'mainroads'}  );


}
###############################################################################
#
# generate_districts - using population size and professionals, determine
# the most likely districts.
#
###############################################################################
sub generate_districts {

    $city->{'districts'}=[];

    if ( $city->{'location'}->{'port'}  ) {
        $xml_data->{'districts'}->{'district'}->{'port'}->{'chance'}=80;
    }

    # use the number of specialists to influence the chance of a district showing up
    foreach my $business (@{$city->{'buildings'}}){
        my $district=$city->{'business'}->{$business->{'content'}}->{'district'};
        $xml_data->{'districts'}->{'district'}->{$district}->{'chance'}+= $city->{'business'}->{$business->{'content'}}->{'specialists'} ;
    }
    # select a number of districts using the size modifier of the city.
    # larger city means more districts, generally speaking.
    my $districtcount= 4 + int($city->{'size_modifier'}/2)+&d(8);
    
    # shuffle the list of districts, 
    foreach my $districtname (shuffle keys %{$xml_data->{'districts'}->{'district'}}){
        my $district=$xml_data->{'districts'}->{'district'}->{$districtname};

        my $districtchance=$district->{'chance'}  + $city->{'size_modifier'}*2 + $city->{$district->{'stat'}};

        if (&d(100) <= $districtchance    and     $districtcount >0 ){
            push @{$city->{'districts'}}, $districtname;
            $districtcount--;
        }
    }

}

###############################################################################
#
# generate_business - using population size and professionals, determine
# the most likely districts.
#
###############################################################################
sub generate_businesses{

    $city->{'business'}={  'total'=>0  };

    #5.5-10.5%  of the population runs a business, depending on the economy
    my $businessestimate=floor($city->{'population'}*(15+($city->{'economy'}+$city->{'size_modifier'} ))/100 );
    $city->{'business'}={ 'estimate'=>$businessestimate };

    # separate each business into priorities
    my $businesspriorities={};

    # Loop throuch each type of building
    for my $business (  @{ $xml_data->{'buildings'}->{'building'} }   ){
        #Note that we're sortiny by priority.
        my $priority= $business->{'priority'};
        if (!defined $businesspriorities->{$priority}){
            $businesspriorities->{$priority}=[];
        }

        #we want to flesh this out according to weight.        
        while ( $business->{'weight'} >0 ){
            my %business2=%$business;
            push @{$businesspriorities->{$priority}}, \%business2;

            $business->{'weight'}=$business->{'weight'}-1;
        }
    }
    my %junkpriority=%$businesspriorities;
    my @weightedbusinesses;
    foreach my $priority (sort { $a <=> $b } keys %junkpriority){
        push @weightedbusinesses, @{$junkpriority{$priority}};
        while ($city->{'business'}->{'estimate'}>0) {
            if (@{$junkpriority{$priority}} >=1){
                my @businesses=shuffle @{$junkpriority{$priority}};
                my $newbusiness=pop @businesses;
                if (!defined $city->{'business'}->{$newbusiness->{'content'}}){
                    $city->{'business'}->{$newbusiness->{'content'}}={'specialists'=>1} ;
                    $city->{'business'}->{$newbusiness->{'content'}}->{'perbuilding'}=$newbusiness->{'perbuilding'};
                    $city->{'business'}->{$newbusiness->{'content'}}->{'weight'}     =$newbusiness->{'weight'};
                    $city->{'business'}->{$newbusiness->{'content'}}->{'priority'}   =$newbusiness->{'priority'};
                }else{
                    $city->{'business'}->{$newbusiness->{'content'}}->{'specialists'}++;
                }
                $city->{'business'}->{'estimate'}--;
                $junkpriority{$priority}=\@businesses;
            }else{
                last;
            }
        }
    }
    @weightedbusinesses=shuffle @weightedbusinesses;
    while ($city->{'business'}->{'estimate'}>0) {

        @weightedbusinesses=shuffle @weightedbusinesses;
        my $newbusiness=$weightedbusinesses[0];
        if (!defined $city->{'business'}->{$newbusiness->{'content'}}){
            #print Dumper $newbusiness->{'district'};
            $city->{'business'}->{$newbusiness->{'content'}}={'specialists'=>1};
        }else{
            $city->{'business'}->{$newbusiness->{'content'}}->{'specialists'}++;
            $city->{'business'}->{$newbusiness->{'content'}}->{'district'}=$newbusiness->{'district'};
        }
 
        $city->{'business'}->{'estimate'}--;
    }
        delete $city->{'business'}->{'estimate'};
    
    foreach my $businessname (keys %{$city->{'business'}}){
#        print Dumper $city->{'business'}->{$businessname};
        $city->{'business'}->{$businessname}->{'count'}=ceil( $city->{'business'}->{$businessname}->{'specialists'} /$city->{'business'}->{$businessname}->{'perbuilding'});
    }


}


###############################################################################
#
# generate_support_area - using population size, determine the size of the
# area needed to support the city. results is in square miles.
#
###############################################################################
sub generate_support_area {
    # Population * (feet per person - sizemodifier*10 ) =total feet per population adjusted for city size
    # a good economy,education, magic and law increases production by  5+5+50+5 36%
    $city->{'supportarea'}=   int($city->{'population'}/ ( 180 + $city->{'economy'} + $city->{'education'} + ($city->{'magic'}+5)*5 +$city->{'order'})*100)/100;

}


###############################################################################
#
# generate_area - using population size and density, determine the size of 
# the city. results is in hectares.
#
###############################################################################
sub generate_area {
    # Population * (feet per person - sizemodifier*10 ) =total feet per population adjusted for city size
    $city->{'area'}=   int( $city->{'population'}*( $city->{'popdensity'}->{'feetpercapita'}-$city->{'size_modifier'}*10   ) /107639*100 )/100; #hectares;

}

###############################################################################
#
# generate_housing - generate the types of housing and how much there is.
#
###############################################################################
sub generate_housing {
    $city->{'housing'}={};

    my @qualitylist= keys %{ $xml_data->{'housing'}->{'quality'}};

    $xml_data->{'housing'}->{'quality'}->{'poor'}->{'percent'}-=($city->{'economy'}*2);
    $xml_data->{'housing'}->{'quality'}->{'average'}->{'percent'}+=($city->{'economy'}*2);

    foreach my $housingquality ( @qualitylist ){

        my $housingtype= $xml_data->{'housing'}->{'quality'}->{$housingquality};

        # fractional housecount total, but you can't have .3 of a house... 
        my $housecount= $city->{'population'}  *   $housingtype->{'percent'}/$housingtype->{'density'}/100;

        # to ensure minimal housing, we require poor housing via ceil, so we always have 1.
        if (defined $housingtype->{'required'}){
            $city->{'housing'}->{$housingquality}        = ceil ($housecount); # ceil used because we want at least 1 poor house
        }else{
            $city->{'housing'}->{$housingquality}        = floor ($housecount);
        }
        $city->{'housing'}->{'total'}+=$city->{'housing'}->{$housingquality}

    }


    # Calculate abandoned by finding 10% of total and adjusting it by economy conditions (+/-5%)
    $city->{'housing'}->{'abandoned'}   = floor($city->{'housing'}->{'total'} *(10-$city->{'economy'} )/100 );

}


###############################################################################
#
# generate_location - select the location we wish to use and any landmarks.
#
###############################################################################


sub generate_location {
    $city->{'location'} = { 'landmarks'=>[]  };
    my $locationlist=$xml_data->{'locations'}->{'location'};

    my $location = rand_from_array(  $locationlist  );
    $city->{'location'}->{'name'}=$location->{'description'};
    $city->{'location'}->{'port'}= ( &d(100) <= $location->{'port_chance'}  );
    if ($city->{'location'}->{'port'}){
        $city->{'location'}->{'portdirection'}=rand_from_array($xml_data->{'direction'}->{'option'})->{'content'};
    }
    #why 20? to give us a better chance of getting one.
    my $landmarkmod=20;
    foreach my $landmark (shuffle @{$location->{'landmarks'}}){
        if (&d(100) <= $landmark->{'chance'}+$landmarkmod){
            push @{$city->{'location'}->{'landmarks'}},  $landmark->{'content'};
            $landmarkmod-=5;
        }
    }
}




###############################################################################
#
# generate_city_credence - select government, ethics, tolerance, etc.
#
###############################################################################
sub generate_city_credence{


    # - Generate ethics
    generate_city_ethics();

    # - Generate beliefs
    generate_city_beliefs();

    # - set govt type
    set_govt_type();

    # - generate seconday power
    generate_secondary_power();

    # - generate laws
    set_laws();

    #generate imprisonment rate
    generate_imprisonment_rate();
}

###############################################################################
#
# generate_imprisonment_rate - city size, authority, order and education
# determine what percentage of the city is in jail. 0.05% to  01.815%
#
###############################################################################

sub generate_imprisonment_rate{
    # should range from ((15-5-5-5)*.5/5+1).5/10=.05% to ((15+5+5+12)*1.5/5+1)/10=1.815
    # high authority means more in jail
    # low education means more in jail
    # larger city means more in jail
    # higher order means more in jail
    $city->{'imprisonment'}={};
    $city->{'imprisonment'}->{'percent'} = (((15 + $city->{'authority'} - $city->{'education'}  +$city->{'size_modifier'} )/5) +1 )*($city->{'order'}+50)/100 /10 ;

    #calculate out the actual prison population in whole numbers
    $city->{'imprisonment'}->{'population'}= ceil( $city->{'imprisonment'}->{'percent'}/100 * $city->{'population'});

    #recalulate to make the percent accurate with the population
    $city->{'imprisonment'}->{'percent'}= int($city->{'imprisonment'}->{'population'}/$city->{'population'}*1000)/10;


}


###############################################################################
#
# generate_city_core - select the size, type, population, races and population
# breakdown. This is the core of the city stats, everything else is icing.
#
###############################################################################
sub generate_city_core{
    # - Generate a size
    set_city_size();

    # - Generate a type
    set_city_type();

    # - Generate a pop_type
    generate_pop_type();

    # - Generate assign races
    assign_races();

    # - Generate pop counts
    generate_pop_counts();

    # - generate city age
    generate_city_age();
    
    # - generate children %
    generate_children();
}



###############################################################################
#
# generate_children - set the percentage of the population that are children, 
# modified by the age of the city
#
###############################################################################
sub generate_children {

    $city->{'children'}={};
    #calculate the pop based on 20 +random factor + city age modifier; should give us a rage between
    # 10% and 45%, which follows the reported international rates of the US census bureau, so STFU.
    $city->{'children'}->{'percent'}= 20 + &d(15) +  $city->{'cityage'}->{'agemod'};

    #calculate out the actual child population in whole numbers
    $city->{'children'}->{'population'}= floor( $city->{'children'}->{'percent'}/100 * $city->{'population'});

    #recalulate to make the percent accurate with the population
    $city->{'children'}->{'percent'}= int($city->{'children'}->{'population'}/$city->{'population'}*1000)/10;

}


###############################################################################
#
# generate_city_age - a simple selector
#
###############################################################################
sub generate_city_age {
    my $agelist=$xml_data->{'cityages'}->{'cityage'};

    $city->{'cityage'}= rand_from_array(  $agelist  );
}


###############################################################################
#
# Generate Secondary Power - select a plot, a power and a subplot.
#
###############################################################################
sub generate_secondary_power {
    $city->{'secondarypower'}={};

    # select a plot
    my $plotlist=$xml_data->{'secondarypower'}->{'plot'};
    $city->{'secondarypower'}->{'plot'} = rand_from_array( $plotlist )->{'content'};

    #select a power and a related subplot.
    my $powerlist=$xml_data->{'secondarypower'}->{'power'} ;
    my $power = rand_from_array(  $powerlist );
    $city->{'secondarypower'}->{'power'} = rand_from_array(  $powerlist )->{'type'};
    if ( &d(100) <= $power->{'subplot_chance'} ){
        $city->{'secondarypower'}->{'subplot'} = rand_from_array(  $power->{'subplot'}  )->{'content'};
    }
}


###############################################################################
#
# set_govt_type - fairly simple; select a type of govt from the list.
#
###############################################################################
sub set_govt_type {
    my $govttypelist=$xml_data->{'govtypes'}->{'govt'} ;
    $city->{'govtype'} = rand_from_array(  $govttypelist  );

    my $descriptorlist=$xml_data->{'govtypes'}->{'descriptor'} ;
    my $descriptor = rand_from_array(  $descriptorlist  );
    $city->{'govtype'}->{'descriptor'}=$descriptor->{'content'};

    # add random element + govtype base approvalmod + descriptor approval + authority mod
    $city->{'govtype'}->{'approvalmod'}    = &d(4)-2 +  $city->{'govtype'}->{'approvalmod'} + $descriptor->{'approvalmod'} +  $city->{'authority'};

    # ensure it falls in the proper range
    $city->{'govtype'}->{'approvalmod'}=max(-5, min(5,  $city->{'govtype'}->{'approvalmod'}   ) );

    $city->{'govtype'}->{'religion'}=&d(4)-2 +  $city->{'govtype'}->{'religion'} ; 

}



###############################################################################
#
# Set Laws - Laws have three facets- enforcement, trial and punishment. 
# Select these from arrays.
#
###############################################################################

sub set_laws {
    $city->{'laws'} = {};
    for my $facet (qw( enforcement trial punishment )) {
        my $facetlist=$xml_data->{'laws'}->{$facet}->{'option'};
        $city->{'laws'}->{$facet} = rand_from_array(  $facetlist  )->{'content'};
    }
}



###############################################################################
#
# generate_city_ethics - Intended for morals and order (classic alignment).
#
###############################################################################
sub generate_city_ethics {
    $city->{'moral'} = &d(100);
    $city->{'order'} = &d(100);

    # adjust all modifiers for each race
    for my $race ( @{ $city->{'races'} } ) {
        $city->{'moral'} += $race->{'moral'};
        $city->{'order'} += $race->{'order'};
    }

    # Use min/max to ensure that we fall in the proper ranges when all is said and done        
    $city->{'moral'}=max(1, min(100, $city->{'moral'} ) );
    $city->{'order'}=max(1, min(100, $city->{'order'} ) );

}
###############################################################################
#
# generate_city_beliefs - This includes other scales, such as determining if 
# the city is a trade hub, etc. 
#
###############################################################################
sub generate_city_beliefs {

    # set the baseline random modifier
    foreach my $scale (qw/ magic authority economy education travel tolerance/ ){
        $city->{$scale}    =&d(4)-2;
    }

    # adjust all modifiers for each race
    for my $race ( @{ $city->{'races'} } ) {
        foreach my $scale (qw/ magic authority economy education travel tolerance/ ){
            $city->{$scale} += $race->{$scale};
        }
    }

    # Use min/max to ensure that we fall in the proper ranges when all is said and done        
    foreach my $scale (qw/ magic authority economy education travel tolerance/ ){
        $city->{$scale}=max(-5, min(5, $city->{$scale} ) );
    }

}

###############################################################################
#
# generate_population_counts - for each race percentage. After getting 
# population counts, recalulate total population, then final percentages.
# note that actual races are not yet associated.
#
###############################################################################
sub generate_pop_counts {
    my $population = $city->{'population'};
    my $newpop     = 0;
    my @races;
    my @newraces;

    # Loop through each race percentage, and get a rough count based
    # on population total
    for my $race ( sort @{ $city->{'races'} } ) {
        $race->{'count'} = ceil( $population * $race->{'percent'} / 100 );
        $newpop += $race->{'count'};
        push @races, $race;
    }

    # Add up all of the rough counts to create a final population total
    $city->{'population'} = $newpop;
    $city->{'races'}      = \@races;

    # Loop through the races a second time, recalulating percentages.
    for my $race ( sort @{ $city->{'races'} } ) {
        $race->{'percent'} = int( $race->{'count'} / $newpop * 1000 ) / 10;
        push @newraces, $race;
    }
    $city->{'races'} = \@newraces;
}


###############################################################################
#
# Assign races. This consists of 
#   * looking at the base population type to gather available base races 
#   * looping through the race percentages and assigning an available race
#   * adding an "off race" if applicable.
#   * adding 1% other    
#
###############################################################################
sub assign_races {
    my $base_pop        = $city->{'base_pop'};
    my @races;


    # Get all of the available race options
    my @available_races = get_races($base_pop);

    # for each race percentage on the city,
    # add assign a race and add it to the list.
    for my $racepercentage ( @{ $city->{'races'} } ) {
        my $newrace = pop(@available_races);
        push @races, add_race_features( $racepercentage, $newrace );
    }


    # If the base_pop has an "off" race, add it.
    if ( $city->{'add_other'} eq 'true' ) {
        my $newrace              = get_other_race($base_pop);
        my $replace_race_id      = &d( scalar @races ) - 1;
        $races[$replace_race_id] = add_race_features( $races[$replace_race_id], $newrace );
    }

    # add the last percent of "others" because mrsassypants didn't grok that
    # things added up to 99% for a reason.
    push @races,add_race_features( {'percent'=>'1'}, get_races('other'));


    #replace race percentages with full race breakdowns.
    $city->{'races'} = \@races;
}


###############################################################################
#
# add_race_features - copy the features over for a given races. Effectively
# merges percent onto the race.
#
###############################################################################

sub add_race_features {
    my ( $race, $newrace ) = @_;
    $race->{'name'}      = $newrace->{'content'};
    $race->{'order'}     = $newrace->{'order'};
    $race->{'moral'}     = $newrace->{'moral'};
    $race->{'magic'}     = $newrace->{'magic'};
    $race->{'authority'} = $newrace->{'auth'};
    $race->{'economy'}   = $newrace->{'econ'};
    $race->{'education'} = $newrace->{'edu'};
    $race->{'travel'}    = $newrace->{'travel'};
    $race->{'tolerance'}    = $newrace->{'toler'};
    $race->{'type'}      = $newrace->{'type'};

    if (defined $race->{'dominant'} ){
        $city->{'dominant_race'}  =  $newrace->{'content'};
    }
    return $race;
}



###############################################################################
#
# get races - get the races that match the given population type.
# If the type is mixed, add the race as long as it's not an other race.
#
###############################################################################

sub get_races {
    my ( $type ) = @_;
    my @races;
    for my $race ( @{ $xml_data->{'races'}->{'race'} } ) {
        if (   ($race->{'type'} eq $type)  or   (($type eq 'mixed') and  ($race->{'type'} ne 'other')) ) {
            push @races, $race;
        }
    }
    return shuffle @races;
} 

###############################################################################
#
# get_other_race - get the races that doesn't match the given population type.
# make sure to exclude other.
#
###############################################################################

sub get_other_race {
    my ($type) = @_;
    my @races;
    for my $race ( shuffle @{ $xml_data->{'races'}->{'race'} } ) {
        if ( $race->{'type'} ne $type  and   ($race->{'type'} ne 'other') ) {
            return $race;
        }
    }
} 

###############################################################################
#
# Generate a Population Type, then populate the population type, population 
# density, and a list of unassigned race percentages.
#
###############################################################################
sub generate_pop_type {
    my $poptype     = roll_from_array( &d(100), $xml_data->{'poptypes'}->{'population'} );
    my $popdensity  = rand_from_array( $xml_data->{'popdensity'}->{'option'} );

    $city->{'popdensity'}   = $popdensity;
    $city->{'poptype'}      = $poptype->{'type'};
    $city->{'races'}        = $poptype->{'option'};
}



###############################################################################
#
# generate_city_name - This consists of the pre,
# the root, the post and the trailer.
#
###############################################################################
sub generate_city_name {
    my $nameobject = parse_object($xml_data->{'cityname'});
    $city->{'nameobj'} = $nameobject;
    my $name="";

    if (defined $nameobject->{'pre'}){
        $name=$nameobject->{'pre'}." ";
    }
    $name.=$nameobject->{'root'}.$nameobject->{'post'};
    if (defined $nameobject->{'trailer'}){
        $name.=" ".$nameobject->{'trailer'};
    }
    return $name;
}


###############################################################################
#
# set_city_type - Find the type of city by selecting it from the citytype list,
# Then populate the base population, type, description and whether 
# or not it's a mixed city.
#
###############################################################################
sub set_city_type {
    my $citytypelist=$xml_data->{'citytype'}->{'city'};
    my $citytype = roll_from_array( &d(100), $citytypelist );

    $city->{'base_pop'}    = $citytype->{'base_pop'};
    $city->{'type'}        = $citytype->{'type'};
    $city->{'description'} = $citytype->{'content'};
    $city->{'add_other'}   = $citytype->{'add_other'};
}


###############################################################################
#
# set_city_size - Find the size of the city by selecting from the citysize 
# list, then populate the size, gp limit, population, and size modifier.
#
###############################################################################
sub set_city_size {
    my $citysizelist=$xml_data->{'citysize'}->{'city'} ;
    my $citysize = roll_from_array( &d(100), $citysizelist );

    $city->{'size'}          = $citysize->{'size'};
    $city->{'gplimit'}       = $citysize->{'gplimit'};
    $city->{'population'}    = $citysize->{'minpop'} + &d( $citysize->{'maxpop'} - $citysize->{'minpop'} );
    $city->{'size_modifier'} = $citysize->{'size_modifier'};
}

#######################################################################################################################
################                                                                                       ################
################                            These are more generic functions                           ################
################                                                                                       ################
#######################################################################################################################
#######################################################################################################################
#######################################################################################################################
#######################################################################################################################


###############################################################################
#
# set_seed - check the parameters for cityID and set the seed accordingly.
# This is what allows us to return to previously generated hosts.
#
###############################################################################
sub set_seed{
    if (defined $q->param('cityid') and  $q->param('cityid')=~/(\d+)/){
        return $1;
    }else{
        return int rand(1000000);
    }
}


###############################################################################
#
# rand_from_array - select a random item from an array.
#
###############################################################################
sub rand_from_array {
    my ($array) = @_;
    my $index = int( rand( scalar @{ $array} ) );
    return $array->[$index];
}

###############################################################################
#
# roll_from_array - When passed a roll and a list of items, check the
# min and max properties of each and select the one that $roll best fits
# otherwise use the first item.
# 
###############################################################################
sub roll_from_array {
    my ( $roll, $items ) = @_;
    my $selected_item = $items->[0];
    for my $item (@$items) {
        if ( $item->{'min'} <= $roll and $item->{'max'} >= $roll ) {
            $selected_item = $item;
            last;
        }
    }
    return $selected_item;
}

###############################################################################
#
# d - this serves the function of rolling a dice- a d6, d10, etc.
#
###############################################################################
sub d {
    my ($die) = @_;
    # d as in 1d6
    if ($die =~/^\d+$/){
        return int( rand($die) );
    }elsif ($die=~/^(\d+)d(\d+)$/){
        my $dicecount=$1;
        my $die=$2;
        my $total=0;
        while ($dicecount-- >0){
            $total+=&d($die);
        }
        return $total;
    }else{
        return 1;
    }
}

#####################################################
#
# Parse Object - a horribly named subroutine to parse
# out and randomly select the parts.
#
#####################################################
sub parse_object {
    my ($object)=@_;
    my $newobj= { 'list'=>[]};
    # We currently only care about 4 parts
    foreach my $part (qw/ pre root post trailer/){
        # Make sure that the part exists for this object.
        if(defined $object->{$part}){

            # If the object is an array, we're going to shuffle
            # the array and select one of the elements.
            if ( ref($object->{$part}) eq 'ARRAY'){
                # Shuffle the array and pop one element off
                my @parts=shuffle( @{$object->{$part}});
                my $newpart=pop(@parts);

                # make sure the element has content;
                # ignore it if it doesn't.
                if (defined $newpart->{'content'}){
                    # If no chance is defined, add it to the list.
                    if (!defined $object->{$part.'_chance'}){
                        push @{$newobj->{'list'}}, $newpart->{'content'};
                        $newobj->{$part}=$newpart->{'content'};

                    # If chance is defined, compare it to
                    # the roll, and add it to the list.
                    } elsif(defined $object->{$part.'_chance'} and &d(100) <= $object->{$part.'_chance'} ) {
                        push @{$newobj->{'list'}}, $newpart->{'content'};
                        $newobj->{$part}=$newpart->{'content'};
                    }
                }
            # If the object is a Hash, we presume that there's only one choice
            } elsif ( ref($object->{$part}) eq 'HASH'  and $object->{$part}->{'content'}){

                # rename for easier handling
                my $newpart=$object->{$part};

                # If no chance is defined, add it to the list.
                if (!defined $object->{$part.'_chance'}){
                    push @{$newobj->{'list'}}, $newpart->{'content'};
                    $newobj->{$part}=$newpart->{'content'};

                # If chance is defined, compare it to
                # the roll, and add it to the list.
                } elsif(defined $object->{$part.'_chance'} and &d(100) <= $object->{$part.'_chance'} ) {
                    push @{$newobj->{'list'}}, $newpart->{'content'};
                    $newobj->{$part}=$newpart->{'content'};
                }
            }
        }
    }
    $newobj->{'content'}=join " ", @{$newobj->{'list'}};
    delete $newobj->{'list'};
    # return the slimmed down version
    return $newobj;
}



