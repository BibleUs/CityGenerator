#!/usr/bin/perl -wT

use strict;
use CGI;
use Data::Dumper;
use List::Util 'shuffle', 'min', 'max' ;
use POSIX;
use XML::Simple;

my $xml = new XML::Simple;

###########################################################
# Yes, this is sloppy. I am aware, but it's also unique.
# Unique, Ubiquitous Singletons.
our $q = CGI->new;
our $xml_data = $xml->XMLin(   "../data.xml", ForceContent => 1, ForceArray  =>[]  );
our $names_data = $xml->XMLin(   "../names.xml", ForceContent => 1, ForceArray  =>[]  );
our $seed=set_seed();
srand $seed;

# This is our city object- it can and will be exported to xml eventually, so keep it clean.
our $city={'seed'=>$seed};
#TODO travelers
# favored weapons
# racial order
#########################################################################
# First thing we need to do is establish a city skeleton of information,
# then fill it in as needed by each subsection of the sample text.
#########################################################################
build_city();


#########################################################################
# Now that $city is fleshed out, we can print it..
#########################################################################

# Show city XML
if (defined $q->param('type') and $q->param('type') eq 'xml' ){
    print $q->header( 'text/xml' );
    print "<?xml version='1.0'  encoding='ISO-8859-1' ?>\n";
    print XMLout($city);
#show city data structure
}elsif (defined $q->param('type') and $q->param('type') eq 'dump' ){
    print $q->header( 'text/plain' );
    print Dumper $city;
# run describe city, but don't print it- useful for debugging
}elsif (defined $q->param('type') and $q->param('type') eq 'debug' ){
    describe_city();
# show the data.xml xml content
}elsif (defined $q->param('type') and $q->param('type') eq 'source' ){
    print $q->header( 'text/xml' );
    print "<?xml version='1.0'  encoding='ISO-8859-1' ?>\n";
    print XMLout($xml_data);
# and if it doesn't match those, do the regular printing of the city.
}else {
    print $q->header;
    print describe_city();
}
        
exit;


#######################################################################################################################
#######################################################################################################################
#######################################################################################################################
#######################################################################################################################
#######################################################################################################################
#######################################################################################################################

sub describe_city {
    my $content=describe_header();
    $content.=describe_summary();
    $content.=describe_geography();
    $content.=describe_cityscape();
    $content.=describe_government();
    $content.=describe_population();
    $content.=describe_economy();
    $content.=describe_current_events();
    $content.=describe_footer();
}
sub describe_header{
    my $style=print_style(); 
    my $content="        <!DOCTYPE html> 
        <html>
            <head>
                <title>City Generator: $city->{'name'} </title>
            $style
            </head>
            <body>";
    return $content;
}
sub describe_footer{
    my $content="
            <footer>
                
                <sub>Note: The purpose of this tool is not to provide you with a complete, logical, feasible city- quite the contrary. The purpose is to give a DM a seed for building their own city. If things don't make sense, try to figure out the conditions that lead to that state. The intersting backstory comes from the DM excercising their imagination.</sub>
                <p><a href='?cityid=$city->{'seed'}&type=xml'>xml version</a>    <a href='?cityid=$city->{'seed'}&type=source'>source data</a>  <a href='?cityid=$city->{'seed'}&type=dump'>raw city data</a> </p>
            </footer>
            </body>
        </html>";
    return $content;
}
#######################################################################################################################
#######################################################################################################################
#######################################################################################################################
#######################################################################################################################
#######################################################################################################################
sub describe_precipitation {
    if (defined $city->{'weather'}->{'precip'}){
        return " and ".$city->{'weather'}->{'precip'};
    }else{
        return "";
    }
}
sub describe_thunder {
    if (defined $city->{'weather'}->{'thunder'}){
        return $city->{'weather'}->{'thunder'};
    }else{
        return "";
    }
}

sub describe_events{
    return "<ul class='two-column'><li>".join('</li><li>',@{$city->{'events'}})."</li></ul>";

}

sub describe_current_events{
    my $precipitation=describe_precipitation();
    my $thunder=describe_thunder();
    my $events=describe_events();
    my $content="
                    <section id='currentevents'>
                        <h2>Current Events</h2>
                        <p>You arrive $city->{'time'}->{'content'}, and can find $city->{'visiblepopulation'} citizens wandering the town.</p>
                        <h3>Weather</h3>
                        <p>The sky $city->{'weather'}->{'clouds'}, the air is $city->{'weather'}->{'air'}, and the wind is $city->{'weather'}->{'wind'}. The temperature is $city->{'weather'}->{'temp'}$precipitation. $thunder</p>
                        <h3>Events</h3>
                        <p>Approaching the city, you can find the following events:</p>
                         $events
                    </section>
";

}




#######################################################################################################################
#######################################################################################################################
sub describe_populations{
    my @populations;
    foreach my $race ( reverse sort {$a->{'percent'} <=> $b->{'percent'}} @{$city->{'races'}}  ){
        push @populations, "$race->{'count'} $race->{'name'} ($race->{'percent'}%)";
    }
    return "<ul><li>".join('</li><li>',@populations)."</li></ul>";


}

sub describe_race_relations{
    my $content="";
    my $racecount=scalar(@{$city->{'races'}}) -1;
    my @races= shuffle @{$city->{'races'}};
    my $instigator= pop @races;
    my @relations;
    while ($racecount-- > 0 and  scalar(@races) >0){
        my $victim= pop @races;
        push @relations, "The $instigator->{'name'} population $instigator->{'tolerancedescription'} the $victim->{'name'} population.\n";
        unshift @races, $instigator;
        $instigator=$victim;

    }
    $content.="<p>Relations between races are varied by individuals, but in general:</p>";
    $content.= "<ul class='one-column'>\n<li>".join("</li>\n<li>",@relations)."</li>\n</ul>\n";
    return $content;
}

sub describe_population{
    my $populations=describe_populations();
    my $racerelations=describe_race_relations();
    my $content="
                    <section id='population'>
                        <h2>Population</h2>
                        <p>$city->{'name'} is a $city->{'moraldescription'} and $city->{'orderdescription'} population$city->{'dominant_race'}. Children account for $city->{'children'}->{'percent'}% ($city->{'children'}->{'population'}), and the elderly account for $city->{'elderly'}->{'percent'}% ($city->{'elderly'}->{'population'}) of this $city->{'cityage'}->{'content'} city. Here's the breakdown of this $city->{'poptype'} population:</p>
                        $populations
                        <h3>Race Relations</h3>
                        $racerelations 
                    </section>
";

}
#######################################################################################################################
#######################################################################################################################

sub describe_resources {
    my @resources;
    #return Dumper $city->{'resource'};
    foreach my $resource (sort {$a->{'content'} cmp $b->{'content'}} @{$city->{'resources'}}){
        push @resources, $resource->{'content'};
    }
    return "<ul><li>".join('</li><li>',@resources)."</li></ul>";
}
sub describe_taverns {
    my @taverns;
    my $tavernpoptotal=0;
    foreach my $tavern (sort {$a->{'name'} cmp $b->{'name'}} @{$city->{'taverns'}}){
        my $tavernstring;
        ($tavernstring,$tavernpoptotal) = describe_tavern($tavern,$tavernpoptotal);
        push @taverns, $tavernstring;
    }
    my $content="";
    if  (scalar(@taverns) >0 ){
        $content.="<p>Taverns are often central gathering places for the citizens. You can find the following Taverns:</p>\n";
        $content.="<ul class='one-column'><li>".join('</li><li>',@taverns)."</li></ul>";
    }else{
        $content.="<p>There are no taverns in this town.</p>\n";
    }
    return $content;
}
sub describe_tavern{
    my ($tavern,$tavernpoptotal)=@_;
    #max =d(12+4 )+10=26
    my $tavernmod= &d($city->{'size_modifier'}+$tavern->{'population'})*2 + $city->{'time'}->{'bar_mod'}  ;

    my $tavernpop=max(0,  min(  int($city->{'population'}/2),   $tavernmod  )  );
    if ($tavernpoptotal+$tavernpop <= int($city->{'population'}/2)){
        $tavern->{'pop_count'}= $tavernpop;
        $tavernpoptotal+=$tavernpop;
    }
    my $name="";
    if ( defined $tavern->{'bartender'}->{'fullname'} ){ $name=" named ".$tavern->{'bartender'}->{'fullname'}  }

    return ("<strong>$tavern->{'name'}</strong> is a $tavern->{'size'}, $tavern->{'condition'} tavern where the $tavern->{'class'} gather. The bar is owned by a $tavern->{'bartender'}->{'race'}$name who seems $tavern->{'bartender'}->{'behavior'}. The law $tavern->{'legal'} the patrons, however most violence is handled by $tavern->{'violence'}. Goods are $tavern->{'costdescription'}. You'll find $tavern->{'pop_count'} citizen(s) here.", $tavernpoptotal);
}

sub describe_localinfo{
    my $content="";
    my @localmarket;
    foreach my $market (  @{$city->{'markets'}}  ){
        push @localmarket, $market->{'name'};
    }
    return "<ul class='one-column'><li>".join('</li><li>',@localmarket)."</li></ul>";
    return $content;
}
sub describe_economy{
    my $resources=describe_resources();
    my $taverns=describe_taverns();
    my $localinfo=describe_localinfo();
    my $content="
                    <section id='economy'>
                        <h2>Economy</h2>
                        <p> The economy is $city->{'economydescription'}, magic is $city->{'magicdescription'}, and education is $city->{'educationdescription'}.
                        <h3>Resources</h3>
                            <p>$city->{'name'} is known for the following:</p>$resources
                        <h3>Taverns</h3>
                            $taverns
                        <h3>Local Info</h3>
                         <p>If one were to dig around enough, they could uncover the following:</p>
                        $localinfo 
                    </section>
";

}

#######################################################################################################################

sub describe_secondarypower{
    my $content=" Within the city there is ".$city->{'secondarypower'}->{'power'}. " that ".$city->{'secondarypower'}->{'plot'}." current leadership";
    if(defined $city->{'secondarypower'}->{'subplot'} ){
        $content.=" while secretly ".$city->{'secondarypower'}->{'subplot'};
    }
    return $content.".";
}
sub describe_approval{
    if ($city->{'govtype'}->{'approvalmod'} <-1){
        return "does not approve of"
    }elsif ($city->{'govtype'}->{'approvalmod'} >1){
        return "approves of"
    }else{
        return "is indifferent towards"
    }
}
sub describe_freedom{
    if ($city->{'govtype'}->{'religion'} <-1){
        return "oppressed"
    }elsif ($city->{'govtype'}->{'religion'} >1){
        return "welcomed"
    }else{
        return "neither oppressed nor supported"
    }
}
sub describe_magic{
    if ($city->{'magic'} <-1){
        return "verboten"
    }elsif ($city->{'magic'} >1){
        return "legal and common"
    }else{
        return "looked upon with suspicion"
    }
}
sub describe_relations {
    my @relations;
#print Dumper $city->{'neighbors'} ; 
    foreach my $neighbor (  @{$city->{'neighbors'}}  ){
        push @relations, $neighbor->{'relation'}." ".$neighbor->{'name'};
    }
    return "<ul class='two-column'><li>".join('</li><li>',@relations)."</li></ul>";
}
sub describe_military{
    my $walls=$city->{'walls'}->{'content'} ;
    if   ( $city->{'walls'}->{'content'} eq 'none'){    
        $walls="lack of defensible wall";
    }
    
    my $content="
                        <p>$city->{'name'} has a $city->{'militarydescription'} attitude towards the military. Their standing army of $city->{'militarystats'}->{'active'} citizens ($city->{'militarystats'}->{'activepercent'}%) is at the ready, with a reserve force of $city->{'militarystats'}->{'reserve'} ($city->{'militarystats'}->{'reservepercent'}%). Of the active duty military, $city->{'militarystats'}->{'para'} ($city->{'militarystats'}->{'parapercent'}%) are special forces and $city->{'militarystats'}->{'kingdom'} ($city->{'militarystats'}->{'kingdompercent'}%) are dedicated to protecting the rest of the $city->{'realm'}.</p>
                        <p> Under duress, a militia of $city->{'militarystats'}->{'militia'} ($city->{'militarystats'}->{'militiapercent'}%) citizens can be raised. Due to their $city->{'militarydescription'} attitude and $walls, $city->{'name'}  $city->{'fortification'}->{'content'} fortified.</p>
";
    return $content;
}
sub describe_government{
    my $secondarypower=describe_secondarypower();
    my $approval=describe_approval();
    my $freedom=describe_freedom();
    my $magic=describe_magic();
    my $relations=describe_relations();
    my $military=describe_military();
    my $content="
                    <section id='government'>
                        <h2>Government</h2>
                        <p>$city->{'name'} is ruled by $city->{'govtype'}->{'descriptor'} $city->{'govtype'}->{'content'}.$secondarypower The population $approval $city->{'govtype'}->{'content'} in general. Freedom of religion is $freedom, and magic use is $magic. </p>

                        <h3>Diplomatic Ties</h3>
                        <p>$city->{'name'} has the following diplomatic relations:</p>
                        $relations
                        <h3>Crime and Punishment</h3>
                        <p>Crime is $city->{'crime'}->{'content'}. Laws are enforced by the $city->{'laws'}->{'enforcer'} $city->{'laws'}->{'enforcement'}. Justice is served $city->{'laws'}->{'trial'}, with a common punishment being $city->{'laws'}->{'punishment'}. The most common crime is $city->{'laws'}->{'commoncrime'}. The imprisonment rate is $city->{'imprisonment'}->{'percent'}% of the population ($city->{'imprisonment'}->{'population'} adult[s]).</p>
                        <h3>Military</h3>
                        $military
                    </section>
";
}

sub describe_district_summary {
    my $content="";
    if (scalar(@{ $city->{'districts'}}) == 1){
         $content=" The city contains a single distinct district.";
    }elsif (scalar(@{ $city->{'districts'}}) > 1){
         $content.=" The city has ".scalar(@{ $city->{'districts'}})." distinct districts.";
    }
    return $content;


}

sub describe_summary {
    if ($city->{'dominant_race'}){$city->{'dominant_race'}=" (which is overwhelmingly ".$city->{'dominant_race'}.")"; }else{$city->{'dominant_race'}=""}
    my $districts=describe_district_summary();
    my $previousid=$city->{'seed'}-1;
    my $nextid=$city->{'seed'}+1;
    my $content="
                    <header>
                       <h1><a href='?cityid=$previousid'>&lt;&lt;</a> <a href='?cityid=$city->{'seed'}'> $city->{'name'} ($city->{'seed'})</a> <a href='?cityid=$nextid'>&gt;&gt;</a></h1>
                        <h2>Summary</h2>
                        <p><b>$city->{'name'}</b> is a $city->{'economydescription'}, $city->{'description'}  of around $city->{'population'} in the $city->{'realm'}$city->{'dominant_race'}.$districts It has a $city->{'climate'}->{'content'} climate.</p>
                    </header>";
}
sub describe_geography {
    my $landmarks= print_landmarks();
    my $neighbors= print_neighbors();
    my $port= ( $city->{'location'}->{'port'} ) ? ' and is a port town' : '';
    my $content="
                    <section id='geography'>
                        <h2>Geography</h2>
                        <p>This $city->{'poptype'} $city->{'size'} is located $city->{'location'}->{'name'}$port. The $city->{'popdensity'}->{'type'} populated town proper is $city->{'area'} hectares, and is supported by a $city->{'supportarea'} hectare region. $landmarks The surrounding region is $city->{'topography'}. $neighbors</p>
                    </section>
";
}
sub describe_port {
    if   ( $city->{'location'}->{'port'} ){
        return " There is a port on the ".$city->{'location'}->{'portdirection'}." side of the city.";
    }

}
sub describe_walls {
    if   ( $city->{'walls'}->{'content'} eq 'none'){
        return " No walls currently surround the city."
    }else{
        return " Visitors are greeted with a ".$city->{'walls'}->{'content'}. " that is ".$city->{'walls'}->{'height'}." feet tall.";
    }
    
}
sub describe_roads {
    return " The city is lined with ". $city->{'streets'}->{ 'content'}.".";
}
sub describe_districts {
    my $content="
                <h3>Districts</h3>";
    if (scalar(@{ $city->{'districts'}})>0){
         $content.="                   The city contains the following Districts:";
        return $content."<ul><li>".join('</li><li>',@{ $city->{'districts'}})."</li></ul>";
    }else{
        return $content."The city contains no districts.";
    }
}
sub describe_housing {
    my @housing;
    foreach my $key (keys %{$city->{'housing'}}){
        if ($key ne "total" and $key ne "abandoned"){
            push @housing, "$key: ".$city->{'housing'}->{$key};
        }
    }
    return "<ul><li>".join('</li><li>',@housing)."</li></ul> <p>Total: $city->{'housing'}->{'total'} homes, $city->{'housing'}->{'abandoned'} abandoned.";
}

sub describe_businesses {

    #return Dumper $city->{'business'};
    if ( scalar( keys %{ $city->{'business'} } ) > 0 ) {
        my @businesses;
        my $buildingcount   = 0;
        my $specialistcount = 0;
        foreach my $key ( sort keys %{ $city->{'business'} } ) {
            my $business = $city->{'business'}->{$key};
            push @businesses, $business->{'count'} . " " . $key . " ($business->{'specialists'} specialists)";
            $specialistcount += $business->{'specialists'};
            $buildingcount   += $business->{'count'};
        } ## end foreach my $key ( sort keys...)
        return
              "You can find the following businesses:<ul><li>"
            . join( '</li><li>', @businesses )
            . "</li></ul><p>Total: $buildingcount buildings, $specialistcount specialists.</p>";
    } else {
        return "The city contains no businesses.";
    }
} ## end sub describe_businesses
sub describe_cityscape {
    my $port=describe_port();
    my $walls=describe_walls();
    my $roads=describe_roads();
    my $districts=describe_districts();
    my $housing=describe_housing();
    my $businesses=describe_businesses();
     $city->{'streets'}->{'mainroads'} = $city->{'streets'}->{'mainroads'} == 0 ? "none": $city->{'streets'}->{'mainroads'};
     $city->{'streets'}->{'mainroads'} = $city->{'streets'}->{'mainroads'} eq "1" ? "1 is": $city->{'streets'}->{'mainroads'}." are";
     $city->{'streets'}->{'roads'} = $city->{'streets'}->{'roads'} == 1 ? "is 1 road": "are ".$city->{'streets'}->{'roads'}." roads";
    my $content="
                    <section id='cityscpae'>
                        <h2>Cityscape</h2>
                        <p>There $city->{'streets'}->{'roads'} leading to $city->{'name'}; $city->{'streets'}->{'mainroads'} major.$port$walls$roads</p>
                        $districts
                        <h3>Housing</h3>
                            The city contains the following housing:$housing
                        <h3>Businesses</h3>
                            $businesses
                    </section>
";
}

###############################################################################
#
# print_neighbors - return the neighbors in an easy-to-display sentence.
#
###############################################################################
sub print_neighbors {
#    print "$seed\n";
    my $neighbors=$city->{'neighbors'};
    if(ref($neighbors) eq 'ARRAY'){
        if (scalar(@$neighbors) eq 1 ){
            return "<a href='?cityid=$neighbors->[0]->{'id'}'> $neighbors->[0]->{'name'}</a> is a neighbor. ";
        
        }elsif(scalar(@$neighbors) >1 ){
       #     print Dumper @$neighbors;
            my @neighborlist=@$neighbors;
            my $lastneighbor=pop(@neighborlist);
            my $content="Neighboring cities include ";
            foreach my $neighbor (@neighborlist){
                $content.="<a href='?cityid=$neighbor->{'id'}'> $neighbor->{'name'}</a>, ";
            }
            $content.=" and <a href='?cityid=$lastneighbor->{'id'}'> $lastneighbor->{'name'}</a>. ";

            return $content; 
        }else{
            return "";
        }
    }
}
###############################################################################
#
# print_landmarks - return the landmarks in an easy-to-display sentence.
#
###############################################################################
sub print_landmarks {
    my $landmarks=$city->{'location'}->{'landmarks'};
#    print Dumper $city->{'location'} ;
    if(ref($landmarks) eq 'ARRAY'){
        if (scalar(@$landmarks) eq 1 ){
            return "A nearby ".$landmarks->[0]." is a local landmark.";
        
        }elsif(scalar(@$landmarks) >1 ){
#            @$landmarks=map {$_->{'content'}}  @$landmarks;
#            print Dumper @$landmarks;
            my $landmarklist=" and ".(pop(@{$landmarks}));
            return "Local landmarks include a ".join(', ', @{$landmarks}) . $landmarklist .".";
        }else{
            return "";
        }
    }
}

###############################################################################
#
# print_style - a simple style to make lists pretty.
#
###############################################################################
sub print_style{

    return "
        <style type='text/css'>
            body{
                background-color:#44aa44;
            }
            section, header{
                padding:5px;
                width:800px;
                margin:auto;
            
            }
            ul{   
                -moz-column-width:222px;
                -webkit-column-width:222px ;
            } 
            .one-column {
                -moz-column-width:800px;
                -webkit-column-width:800px ;
            } 
            .one-column li {
                padding-bottom:5px;
            } 
            .two-column ul{
                -moz-column-width:250px;
                -webkit-column-width:250px ;
            } 
        </style>\n";
}




#######################################################################################################################
#######################################################################################################################
#######################################################################################################################
#######################################################################################################################
#######################################################################################################################
#######################################################################################################################



###############################################################################
#
# build_city - This is the primary method for building a city. using $seed, 
# generate the city name, then the core, creedence, physical traits, economy, 
# military and current events. Once that's finished you have a fully
# funcitonal city.
#
###############################################################################

sub build_city {
    $city={'seed'=>$seed};
    $city->{'name'}= parse_object($xml_data->{'cityname'})->{'content'};

    generate_city_core();
    generate_city_credence();
    generate_physical_traits();
    generate_economics();
    generate_military();
    generate_current_events();

}

###############################################################################
#
# generate_city_core - select the size, type, population, races and population
# breakdown. This is the core of the city stats, everything else is icing.
#
###############################################################################

sub generate_city_core{
    set_city_size();
    set_city_type();
    generate_pop_type();
    assign_races();
    generate_pop_counts();
    generate_city_age();
    generate_children();
    generate_elderly();
}

###############################################################################
#
# generate_city_credence - select government, ethics, tolerance, etc.
#
###############################################################################

sub generate_city_credence {
    generate_city_ethics();
    generate_city_beliefs();
    set_govt_type();
    generate_secondary_power();
    set_laws();
    generate_crime();
    generate_imprisonment_rate();
}

###############################################################################
#
# generate_physical_traits - Generate the location, size, support area, 
# landmarks, 
#
###############################################################################

sub generate_physical_traits {
    generate_realm();
    generate_location();
    generate_climate();
    generate_housing();
    generate_area();
    generate_support_area();
    generate_businesses();
    generate_districts();
    generate_streets();
    generate_walls();
    generate_neighbors();
    generate_topography();
}

###############################################################################
#
# generate_economics - generate various markets, organizations and resources
#
###############################################################################

sub generate_economics {
    generate_markets();
    generate_resources();
    generate_taverns();
    generate_travelers();
    generate_economic_description();
    generate_education_description();
    generate_magic_description();
}

###############################################################################
#
# generate_military - generate military, fortifications, wars, etc
#
###############################################################################

sub generate_military {
    generate_military_stats();
    generate_fortifications();
    generate_kingdom_troops();
#    generate_seige();
}
###############################################################################
#
# generate_kingdom_troops - generate troops dedicated to protecting the kingdom.
#
###############################################################################

sub generate_kingdom_troops {
    $city->{'militarystats'}->{'kingdompercent'}=&d(4)*10 + $city->{'size_modifier'};
    
    $city->{'militarystats'}->{'kingdom'}       = int($city->{'militarystats'}->{'active'} * $city->{'militarystats'}->{'kingdompercent'}/100);
    $city->{'militarystats'}->{'kingdompercent'}= int($city->{'militarystats'}->{'kingdom'}/ $city->{'militarystats'}->{'active'} * 1000)/10;
    
}

###############################################################################
#
# generate_fortifications - generate fortifications
#
###############################################################################

sub generate_fortifications {
    my $roll;
    if ($city->{'walls'}->{'content'} eq 'none' ){
        $roll=&d(45);
        $city->{'fortification'}=roll_from_array( $roll  ,$xml_data->{'fortification'}->{'option'}) ;
    }else{
        $roll=&d(100) + $city->{'walls'}->{'height'};
        $city->{'fortification'}=roll_from_array( $roll  ,$xml_data->{'fortification'}->{'option'}) ;
    }
    $city->{'fortification'}->{'roll'}=$roll;
}

###############################################################################
#
# generate_military_stats - generate percentage of militant population
#
###############################################################################

sub generate_military_stats {
    $city->{'militarystats'}={};
    #factors - is there a barraks district? +10%
    # order, mil, authority,
    # base military
    $city->{'militarystats'}->{'activepercent'}  = max(0, 10 + $city->{'military'} + ($city->{'govtype'}->{'mil_mod'}  +  $city->{'authority'})/2  );
    $city->{'militarystats'}->{'reservepercent'} = max(0,  3 + $city->{'military'} + ($city->{'govtype'}->{'mil_mod'}  +  $city->{'authority'})/4   ) ;
    $city->{'militarystats'}->{'parapercent'}    = max(0,  7 + $city->{'military'} +  $city->{'govtype'}->{'mil_mod'} );
    $city->{'militarystats'}->{'inelegable_pop'} = int( $city->{'imprisonment'}->{'population'} + $city->{'children'}->{'population'}/2 +$city->{'elderly'}->{'population'});

    $city->{'militarystats'}->{'active'}  =  int ($city->{'population'}                * $city->{'militarystats'}->{'activepercent'}/100)  ;
    $city->{'militarystats'}->{'reserve'} =  int ($city->{'population'}                * $city->{'militarystats'}->{'reservepercent'}/100) ;
    $city->{'militarystats'}->{'para'}    =  int ($city->{'militarystats'}->{'active'} * $city->{'militarystats'}->{'parapercent'}/100)    ;
    $city->{'militarystats'}->{'militia'} =  int ($city->{'population'} - $city->{'militarystats'}->{'inelegable_pop'} );

    $city->{'militarystats'}->{'activepercent'}  = int (  $city->{'militarystats'}->{'active'}/$city->{'population'}*10000  )/100;
    $city->{'militarystats'}->{'reservepercent'} = int (  $city->{'militarystats'}->{'reserve'}/$city->{'population'}*10000  )/100;
    $city->{'militarystats'}->{'parapercent'}    = int (  $city->{'militarystats'}->{'para'}/$city->{'militarystats'}->{'active'} *10000  )/100;
    $city->{'militarystats'}->{'militiapercent'} = int (  $city->{'militarystats'}->{'militia'}/$city->{'population'}*10000  )/100;
    
}

###############################################################################
#
# generate_current_events - generate weather conditions, visible population,
# and ongoing events.
#
###############################################################################
sub generate_current_events {
    generate_time();
    generate_weather();
    generate_visible_population();
    generate_events();
}


###############################################################################
###############################################################################



###############################################################################
#
# generate_events - determine what is going on in the city currently.
#
###############################################################################
sub generate_events {
    my $event_chance=$xml_data->{'events'}->{'chance'};
    my $limit=max(2, $city->{'size_modifier'}/2);
    $city->{'eventslimit'}=$limit;
    $city->{'events'}=[];
    my @events;

    for my $event (shuffle @{ $xml_data->{'events'}->{'event'} } ){
        if ($limit > 0 ){
            my $eventname=$event->{'type'};
            my $desc = rand_from_array(  $event->{'option'}  )->{'content'};
            push @{$city->{'events'}}, $desc.$eventname;
            $limit--;
        }
    }

}


###############################################################################
#
# generate_visible_population - determine what percentage of the population is
# out and about.
#
###############################################################################
sub generate_visible_population {

    my $pop=$city->{'population'};
    my $timemodifier=$city->{'time'}->{'public_modifier'};
    my $sizemodifier=$city->{'size_modifier'};

    # baseline visiblepop is 1/(10+ size modifier) of the population
    my $visiblepop=ceil($pop/(10+$sizemodifier) );

    if ($timemodifier >0){
        $visiblepop=$visiblepop*$timemodifier;
    }elsif ($timemodifier <0){
        # fancy calculation to make less people at night and more in the day
        # I don't remember how this worked out so well.
        $visiblepop=ceil sqrt($visiblepop/abs($timemodifier))+abs($timemodifier);
        if ($sizemodifier >0){
            $visiblepop*=$sizemodifier;
        }
    }

    # If it's raining/snowing/etc, cut the population in half
    if (defined $city->{'weather'}->{'precip'} ) {
        $visiblepop=ceil($visiblepop/2);
    }
    # If it's thundering, cut the population in half again
    if (defined $city->{'weather'}->{'thunder'} ) {
        $visiblepop=ceil($visiblepop/2);
    }
    # Finally, if it's not nice out, cut the population even further.
    $visiblepop=ceil($visiblepop*$city->{'weather'}->{'tempmodifier'});

    $city->{'visiblepopulation'}=$visiblepop;
}
###############################################################################
#
# generate_weather - set the weather, which determines visible population
#
###############################################################################
sub generate_weather {
    $city->{'weather'} ={};
    $city->{'weather'}->{'forecast'} = rand_from_array( $xml_data->{'weather'}->{'forecast'}->{'option'} )->{'content'};
    my $temp = rand_from_array( $xml_data->{'weather'}->{'temp'}->{'option'} );
    $city->{'weather'}->{'tempmodifier'}=$temp->{'modifier'};
    $city->{'weather'}->{'temp'}=$temp->{'content'};

    $city->{'weather'}->{'air'} = rand_from_array( $xml_data->{'weather'}->{'air'}->{'option'} )->{'content'};
    $city->{'weather'}->{'wind'} = rand_from_array( $xml_data->{'weather'}->{'wind'}->{'option'} )->{'content'};
    $city->{'weather'}->{'clouds'} = rand_from_array( $xml_data->{'weather'}->{'clouds'}->{'option'} )->{'content'};
    if (&d(100) <= $xml_data->{'weather'}->{'thunder'}->{'chance'}){
        $city->{'weather'}->{'thunder'} = rand_from_array( $xml_data->{'weather'}->{'thunder'}->{'option'} )->{'content'};
    }
    if (&d(100) <= $xml_data->{'weather'}->{'precip'}->{'chance'}){
        my $precip = rand_from_array( $xml_data->{'weather'}->{'precip'}->{'option'} );
        $city->{'weather'}->{'precip'}= $precip->{'description'};
        if (defined $precip->{'type'} ){
            $city->{'weather'}->{'precip'} = rand_from_array( $precip->{'type'} )->{'content'} . $city->{'weather'}->{'precip'} ;

        }
    }
}

###############################################################################
#
# generate_time - set the current time, which determines visible population
#
###############################################################################
sub generate_time {
    $city->{'time'} = rand_from_array( $xml_data->{'time'}->{'option'} );
}


###############################################################################
#
# generate_education_description - generate the economic description
#
###############################################################################
sub generate_education_description {
    my $educationtype     = roll_from_array( $city->{'education'}, $xml_data->{'educationalignment'}->{'option'} );
    my $adjective     = rand_from_array( $educationtype->{'adjective'} )->{'content'};
    $city->{'educationdescription'}=$adjective;
}

###############################################################################
#
# generate_magic_description - generate the economic description
#
###############################################################################
sub generate_magic_description {
    my $magictype     = roll_from_array( $city->{'magic'}, $xml_data->{'magicalignment'}->{'option'} );
    my $adjective     = rand_from_array( $magictype->{'adjective'} )->{'content'};
    $city->{'magicdescription'}=$adjective;
}

###############################################################################
#
# generate_economic_description - generate the economic description
#
###############################################################################
sub generate_economic_description {
    my $econtype     = roll_from_array( $city->{'economy'}, $xml_data->{'economyalignment'}->{'option'} );
    my $adjective     = rand_from_array( $econtype->{'adjective'} )->{'content'};
    $city->{'economydescription'}=$adjective;
}

###############################################################################
#
# generate_travelers - generate a few travelers
#
###############################################################################
sub generate_travelers{
    my $travelercount= int( ( 7 +  $city->{'size_modifier'} )/2);
    $city->{'travelers'}=[];
    while ($travelercount-- ){
        #TODO switch to roll_from_array
        my $travelerclass= rand_from_array( [ keys %{$xml_data->{'classes'}->{'class'}}] );
        my $traveler=$xml_data->{'classes'}->{'class'}->{$travelerclass};
        $traveler->{'class'}=$travelerclass;
        $traveler->{'level'}= min( 20 ,max(1, &d($traveler->{'max_level'}) + &d( $city->{'size_modifier'} )) ) ;
    
        push @{$city->{'travelers'}}, $traveler;

    }

}

###############################################################################
#
# generate_taverns - generate a few taverns;
#
###############################################################################

sub generate_taverns{
    my $taverncount=0;
    if (defined $city->{'business'}->{'tavern/inn'}){
        $taverncount+=$city->{'business'}->{'tavern/inn'}->{'count'};
    }
    $taverncount=min(5 ,  $taverncount);
    $city->{'taverns'}=[];
    while ($taverncount-- > 0){
        my $tavern->{'name'}= parse_object($xml_data->{'taverns'} )->{'content'};
        $tavern->{'cost'}=$city->{'economy'};
        $tavern->{'population'}=0;

        $tavern->{'size'}=rand_from_array( $xml_data->{'taverns'}->{'size'}   );
        $tavern->{'cost'}+=$tavern->{'size'}->{'cost_mod'};
        $tavern->{'population'}+=$tavern->{'size'}->{'pop_mod'};
        $tavern->{'size'}=$tavern->{'size'}->{'content'};

        $tavern->{'condition'}=rand_from_array( $xml_data->{'taverns'}->{'condition'}   );
        $tavern->{'cost'}+=$tavern->{'condition'}->{'cost_mod'};
        $tavern->{'condition'}=$tavern->{'condition'}->{'content'};

        $tavern->{'class'}=roll_from_array( &d(100),$xml_data->{'taverns'}->{'class'}   );
        $tavern->{'cost'}+=max(-5,min(5,$tavern->{'class'}->{'cost_mod'}));
        $tavern->{'class'}=$tavern->{'class'}->{'content'};

        $tavern->{'violence'}=rand_from_array( $xml_data->{'taverns'}->{'violence'}   )->{'content'};
        $tavern->{'legal'}=rand_from_array( $xml_data->{'taverns'}->{'legal'}   )->{'content'};

        $tavern->{'costdescription'}=roll_from_array( $tavern->{'cost'}, $xml_data->{'taverns'}->{'cost'}   )->{'content'};
        $tavern->{'bartender'}=generate_bartender();

        push @{$city->{'taverns'}}, $tavern;
    }

}

###############################################################################
#
# generate_bartender - generate a bartender
#
###############################################################################
sub generate_bartender{

    my $bartender;
    $bartender->{'behavior'}=rand_from_array( $xml_data->{'behavioraltraits'}->{'trait'} )->{'type'};
    my @races=get_races(   $city->{'base_pop'}    );
    $bartender->{'race'}= pop(@races)->{'content'} ;
    $bartender->{'level'}= min( 20 ,max(1, &d("3d4")+ &d( $city->{'size_modifier'} )) ) ;

    my $race= lc $bartender->{'race'};

    if (defined $names_data->{'race'}->{ $race}     ){
        my $racenames=$names_data->{'race'}->{ $race} ;
        if ( defined $racenames->{'firstname'} ){
            $bartender->{'firstname'}= parse_object(    $racenames->{'firstname'}         )->{'content'};
            $bartender->{'fullname'}=$bartender->{'firstname'};
        }
        if ( defined $racenames->{'lastname'} ){
            $bartender->{'lastname'}= parse_object(    $racenames->{'lastname'}         )->{'content'};
            $bartender->{'fullname'}=$bartender->{'lastname'};
        }
        if ( defined $racenames->{'firstname'}  and defined $racenames->{'lastname'} ){
            $bartender->{'fullname'}=$bartender->{'firstname'} ." ". $bartender->{'lastname'};
        }
    }

    return $bartender;


}

###############################################################################
#
# generate_resources - select resources modified by city size.
#
###############################################################################

sub generate_resources{
    #ensure that the resource count is at most 10 and at least 0
    my $resource_count=min( max($city->{'size_modifier'}+$city->{'economy'}, 0),10) ;

    #shift from 0-10 to 2-12
    $resource_count = int( rand( $resource_count ))+2;

    $city->{'resources'}=[];
    while ($resource_count-- > 0 ){
        my $resource=rand_from_array($xml_data->{'resources'}->{'resource'});
        push @{ $city->{'resources'} }, parse_object($resource);
    }

}


###############################################################################
#
# generate_markets - select some markets according to their chance of 
# appearance modified by city size.
#
###############################################################################
sub generate_markets {

    $city->{'markets'}=[];

    # minimum of 2 markets, max of size modifier(9)
    my $marketcount= max(2, &d( int(7 + $city->{'size_modifier'})/2     ));


    # loop through the marketcount to randomly select markets
    # this allows us to get "duplicates""
    while ( $marketcount > 0 ){

        # get a shuffled list of markets
        my @markets=shuffle @{ $xml_data->{'markets'}->{'option'} };

        #pop a single market off
        my $market = pop  @markets ;

        # modify the chance of the market by the size modifier
        my $chance_of_market= $market->{'chance'} +  $city->{'size_modifier'};

        # if we succeed, decrement the marketcount and push the market to 
        # our queue
        if (&d(100) <= $chance_of_market){
            $marketcount--;
            my $newmarket={ 
                                'type'=> $market->{'type'}, 
                                'name'=> $market->{'marketname'}.' '.$market->{'type'}
                            };
            # set market secret
            if ( &d(100) <$market->{'secret'} ){
                $newmarket->{'secret'}='secret ';
            }else{
                $newmarket->{'secret'}='';
            }

            # select market detail
            if ( &d(100) > 50 ){
                my $marketoption=rand_from_array($market->{'option'});
                $newmarket->{'name'}=  $newmarket->{'secret'}. $marketoption->{'content'}.' '.$newmarket->{'name'};
            }

            # push it to the queue
            push @{$city->{'markets'}}, $newmarket;

       } 

    }

}








###############################################################################
#
# generate_realm - Determine the realm of the city

#
###############################################################################
sub generate_realm {
    my $newseed=$seed-$seed%20;
    srand $newseed;
    $city->{'realm'}=parse_object($xml_data->{'realm'})->{'content'};
    srand $seed;
}

###############################################################################
#
# generate_climate - Determine the climate of the city
#
###############################################################################
sub generate_climate {
    $city->{'climate'}=rand_from_array($xml_data->{'climate'}->{'option'});
}


###############################################################################
#
# generate_topography - Determine information about the neighbors. 
#
###############################################################################
sub generate_topography {
    $city->{'topography'}=rand_from_array($xml_data->{'topography'}->{'region'})->{'content'};
}

###############################################################################
#
# generate_neighbors - Determine information about the neighbors. 
#
###############################################################################
sub generate_neighbors {
    my $neighbortotal=1+&d(3);
    $city->{'neighbors'}=[];
    my $neighborcount=-int($neighbortotal/2)-1;
    while($neighborcount< ceil($neighbortotal/2)+1){
        my $newseed=$seed+$neighborcount ;
        if ($newseed != $seed){
            srand( $newseed );
            my $neighbor->{'id'}=$newseed;
            $neighbor->{'name'}= parse_object($xml_data->{'cityname'})->{'content'};

            $neighbor->{'relation'} = rand_from_array(  $xml_data->{'neighbor'}->{'relation'}  )->{'content'};
            push @{$city->{'neighbors'}}, $neighbor;
        }
        $neighborcount++;
    }
}


###############################################################################
#
# generate_walls - Determine information about the streets. 
#
###############################################################################
sub generate_walls {
    my $roll=&d(20)+ $city->{'size_modifier'} ;
    if( $xml_data->{'walls'}->{'chance'}< $roll){
        $city->{'walls'}=parse_object($xml_data->{'walls'});
        $city->{'walls'}->{'height'}= 8 +&d(10) + $city->{'size_modifier'};
    }else{
        $city->{'walls'}->{'content'}="none";
        $city->{'walls'}->{'height'}=0;
    }
}

###############################################################################
#
# generate_streets - Determine information about the streets. 
#
###############################################################################
sub generate_streets {
    $city->{'streets'}=parse_object($xml_data->{'streets'});

    $city->{'streets'}->{'mainroads'}=max(0,   int(($city->{'travel'}+$city->{'economy'})/3)  );
    $city->{'streets'}->{'roads'}=max(1,   int(($city->{'travel'}+$city->{'economy'})/3) + $city->{'streets'}->{'mainroads'}  );


}
###############################################################################
#
# generate_districts - using population size and professionals, determine
# the most likely districts.
#
###############################################################################
sub generate_districts {

    $city->{'districts'}=[];

    if ( $city->{'location'}->{'port'}  ) {
        $xml_data->{'districts'}->{'district'}->{'port'}->{'chance'}=80;
    }

    # use the number of specialists to influence the chance of a district showing up
    foreach my $business (@{$city->{'buildings'}}){
        my $district=$city->{'business'}->{$business->{'content'}}->{'district'};
        $xml_data->{'districts'}->{'district'}->{$district}->{'chance'}+= $city->{'business'}->{$business->{'content'}}->{'specialists'} ;
    }
    # select a number of districts using the size modifier of the city.
    # larger city means more districts, generally speaking.
    my $districtcount= 4 + int($city->{'size_modifier'}/2)+&d(8);
    
    # shuffle the list of districts, 
    foreach my $districtname (shuffle keys %{$xml_data->{'districts'}->{'district'}}){
        my $district=$xml_data->{'districts'}->{'district'}->{$districtname};

        my $districtchance=$district->{'chance'}  + $city->{'size_modifier'}*2 + $city->{$district->{'stat'}};

        if (&d(100) <= $districtchance    and     $districtcount >0 ){
            push @{$city->{'districts'}}, $districtname;
            $districtcount--;
        }
    }

}

###############################################################################
#
# generate_business - using population size and professionals, determine
# the most likely districts.
#
###############################################################################
sub generate_businesses{

    $city->{'business'}={  'total'=>0  };

    #5.5-10.5%  of the population runs a business, depending on the economy
    my $businessestimate=floor($city->{'population'}*(15+($city->{'economy'}+$city->{'size_modifier'} ))/100 );
    $city->{'business'}={ 'estimate'=>$businessestimate };

    # separate each business into priorities
    my $businesspriorities={};

    # Loop throuch each type of building
    for my $business (  @{ $xml_data->{'buildings'}->{'building'} }   ){
        #Note that we're sortiny by priority.
        my $priority= $business->{'priority'};
        if (!defined $businesspriorities->{$priority}){
            $businesspriorities->{$priority}=[];
        }

        #we want to flesh this out according to weight.        
        while ( $business->{'weight'} >0 ){
            my %business2=%$business;
            push @{$businesspriorities->{$priority}}, \%business2;

            $business->{'weight'}=$business->{'weight'}-1;
        }
    }
    my %junkpriority=%$businesspriorities;
    my @weightedbusinesses;
    foreach my $priority (sort { $a <=> $b } keys %junkpriority){
        push @weightedbusinesses, @{$junkpriority{$priority}};
        while ($city->{'business'}->{'estimate'}>0) {
            if (@{$junkpriority{$priority}} >=1){
                my @businesses=shuffle @{$junkpriority{$priority}};
                my $newbusiness=pop @businesses;
                if (  $city->{'size_modifier'}  >=   $newbusiness->{'requires_size'}  ){
                    if (!defined $city->{'business'}->{$newbusiness->{'content'}}){
                        $city->{'business'}->{$newbusiness->{'content'}}={'specialists'=>1} ;
                        $city->{'business'}->{$newbusiness->{'content'}}->{'perbuilding'}=$newbusiness->{'perbuilding'};
                        $city->{'business'}->{$newbusiness->{'content'}}->{'weight'}     =$newbusiness->{'weight'};
                        $city->{'business'}->{$newbusiness->{'content'}}->{'priority'}   =$newbusiness->{'priority'};
                        $city->{'business'}->{$newbusiness->{'content'}}->{'requires_size'}   =$newbusiness->{'requires_size'};
                    }else{
                        $city->{'business'}->{$newbusiness->{'content'}}->{'specialists'}++;
                    }
                }
                $city->{'business'}->{'estimate'}--;
                $junkpriority{$priority}=\@businesses;
            }else{
                last;
            }
        }
    }
    @weightedbusinesses=shuffle @weightedbusinesses;
    while ($city->{'business'}->{'estimate'}>0) {

        @weightedbusinesses=shuffle @weightedbusinesses;
        my $newbusiness=$weightedbusinesses[0];
        # To show, an alchemist (0), the modifier must be 0 or greater
        if (  $city->{'size_modifier'}  >=   $newbusiness->{'requires_size'}  ){
            if (!defined $city->{'business'}->{$newbusiness->{'content'}}){
                #print Dumper $newbusiness->{'district'};
                $city->{'business'}->{$newbusiness->{'content'}}={'specialists'=>1};
            }else{
                $city->{'business'}->{$newbusiness->{'content'}}->{'specialists'}++;
                    $city->{'business'}->{$newbusiness->{'content'}}->{'district'}=$newbusiness->{'district'};
            }
            $city->{'business'}->{'estimate'}--;
        }
    }
        delete $city->{'business'}->{'estimate'};
    
    foreach my $businessname (keys %{$city->{'business'}}){
#        print Dumper $city->{'business'}->{$businessname};
        $city->{'business'}->{$businessname}->{'count'}=ceil( $city->{'business'}->{$businessname}->{'specialists'} /$city->{'business'}->{$businessname}->{'perbuilding'});
    }


}


###############################################################################
#
# generate_support_area - using population size, determine the size of the
# area needed to support the city. results is in square miles.
#
###############################################################################
sub generate_support_area {
    # Population * (feet per person - sizemodifier*10 ) =total feet per population adjusted for city size
    # low fpp = successful
    # a good economy,education, magic and law increases production by  5+5+50+5 36%
    # ranges from 5+5+50+50=+110=290 to -5-5-50+0=-60 =0
    # base+ed+econ + (order-50) + magic= 290 people per sqmile
    # base+ed+econ + (order-50) + magic= 0 people per sqmile
    # a desert with no economy, no education, no magic and no order can't support anyone.

    my $people_per_sq_mile= $city->{'climate'}->{'pop_support'}+ $city->{'economy'} + $city->{'education'} + ($city->{'order'}-50) +  ($city->{'magic'}+5)*5 ;
    $city->{'supportarea'}=   int($city->{'population'}/$people_per_sq_mile *100*258.999  )/100;
}



###############################################################################
#
# generate_area - using population size and density, determine the size of 
# the city. results is in hectares.
#
###############################################################################
sub generate_area {
    # Population * (feet per person - sizemodifier*10 ) =total feet per population adjusted for city size
    $city->{'area'}=   int( $city->{'population'}*( $city->{'popdensity'}->{'feetpercapita'}-$city->{'size_modifier'}*10   ) /107639*100 )/100; #hectares;

}

###############################################################################
#
# generate_housing - generate the types of housing and how much there is.
#
###############################################################################
sub generate_housing {
    $city->{'housing'}={};

    my @qualitylist= keys %{ $xml_data->{'housing'}->{'quality'}};

    $xml_data->{'housing'}->{'quality'}->{'poor'}->{'percent'}-=($city->{'economy'}*5);
    $xml_data->{'housing'}->{'quality'}->{'average'}->{'percent'}+=($city->{'economy'}*5);

    foreach my $housingquality ( @qualitylist ){

        my $housingtype= $xml_data->{'housing'}->{'quality'}->{$housingquality};

        # fractional housecount total, but you can't have .3 of a house... 
        my $housecount= $city->{'population'}  *   $housingtype->{'percent'}/$housingtype->{'density'}/100;

        # to ensure minimal housing, we require poor housing via ceil, so we always have 1.
        if (defined $housingtype->{'required'}){
            $city->{'housing'}->{$housingquality}        = ceil ($housecount); # ceil used because we want at least 1 poor house
        }else{
            $city->{'housing'}->{$housingquality}        = floor ($housecount);
        }
        $city->{'housing'}->{'total'}+=$city->{'housing'}->{$housingquality}

    }

    # Calculate abandoned by finding 11% of total and adjusting it by economy conditions (+/-10%), min of 1
    $city->{'housing'}->{'abandoned'}   = ceil($city->{'housing'}->{'total'} *(11-($city->{'economy'})*2 )/100 );

}

###############################################################################
#
# generate_location - select the location we wish to use and any landmarks.
#
###############################################################################


sub generate_location {
    $city->{'location'} = { 'landmarks'=>[]  };
    my $locationlist=$xml_data->{'locations'}->{'location'};

    my $location = rand_from_array(  $locationlist  );
    $city->{'location'}->{'name'}=$location->{'description'};
    $city->{'location'}->{'port'}= ( &d(100) <= $location->{'port_chance'}  );
    if ($city->{'location'}->{'port'}){
        $city->{'location'}->{'portdirection'}=rand_from_array($xml_data->{'direction'}->{'option'})->{'content'};
    }
    #why 20? to give us a better chance of getting one.
    my $landmarkmod=20;
    foreach my $landmark (shuffle @{$location->{'landmarks'}}){
        if (&d(100) <= $landmark->{'chance'}+$landmarkmod){
            push @{$city->{'location'}->{'landmarks'}},  $landmark->{'content'};
            $landmarkmod-=5;
        }
    }
}


sub generate_crime{
    #higher means more crime
    # random -education + authority averaged with reversed morality.
    # low morality= high reversed morality, which raises the average
    my $crime_roll= int((&d(100) + $city->{'education'} - $city->{'authority'} + ( 100 - $city->{'moral'}) )/2);

    $city->{'crime'}= roll_from_array($crime_roll, $xml_data->{'crime'}->{'option'});
    $city->{'crime'}->{'roll'}=$crime_roll;

}

###############################################################################
#
# generate_imprisonment_rate - city size, authority, order and education
# determine what percentage of the city is in jail. 0.05% to  01.815%
#
###############################################################################

sub generate_imprisonment_rate{
    # should range from ((15-5-5-5)*.5/5+1).5/10=.05% to ((15+5+5+12)*1.5/5+1)/10=1.815
    # high authority means more in jail
    # low education means more in jail
    # larger city means more in jail
    # higher order means more in jail
    $city->{'imprisonment'}={};
    $city->{'imprisonment'}->{'percent'} = (((15 + $city->{'authority'} - $city->{'education'}  +$city->{'size_modifier'} )/5) +1 )*($city->{'order'}+50)/100 /10 ;

    #calculate out the actual prison population in whole numbers
    $city->{'imprisonment'}->{'population'}= ceil( $city->{'imprisonment'}->{'percent'}/100 * $city->{'population'});

    #recalulate to make the percent accurate with the population
    $city->{'imprisonment'}->{'percent'}= int($city->{'imprisonment'}->{'population'}/$city->{'population'}*1000)/10;


}



###############################################################################
#
# generate_elderly - set the percentage of the population that are elderly, 
# modified by the age of the city
#
###############################################################################
sub generate_elderly {

    $city->{'elderly'}={};
    #calculate the pop based on 10 +random factor - city age modifier; should give us a rage between
    # 1% and 26%, which follows the reported international rates of the US census bureau, so STFU.
    $city->{'elderly'}->{'percent'}= max(1.5, (6 + &d(5) -  $city->{'cityage'}->{'agemod'})  );

    #calculate out the actual child population in whole numbers
    $city->{'elderly'}->{'population'}= ceil( $city->{'elderly'}->{'percent'}/100 * $city->{'population'});

    #recalulate to make the percent accurate with the population
    $city->{'elderly'}->{'percent'}= ceil($city->{'elderly'}->{'population'}/$city->{'population'}*1000)/10;

}


###############################################################################
#
# generate_children - set the percentage of the population that are children, 
# modified by the age of the city
#
###############################################################################
sub generate_children {

    $city->{'children'}={};
    #calculate the pop based on 20 +random factor + city age modifier; should give us a rage between
    # 10% and 45%, which follows the reported international rates of the US census bureau, so STFU.
    $city->{'children'}->{'percent'}= 20 + &d(15) +  $city->{'cityage'}->{'agemod'};

    #calculate out the actual child population in whole numbers
    $city->{'children'}->{'population'}= floor( $city->{'children'}->{'percent'}/100 * $city->{'population'});

    #recalulate to make the percent accurate with the population
    $city->{'children'}->{'percent'}= int($city->{'children'}->{'population'}/$city->{'population'}*1000)/10;

}


###############################################################################
#
# generate_city_age - a simple selector
#
###############################################################################
sub generate_city_age {
    my $agelist=$xml_data->{'cityages'}->{'cityage'};

    $city->{'cityage'}= rand_from_array(  $agelist  );
}


###############################################################################
#
# Generate Secondary Power - select a plot, a power and a subplot.
#
###############################################################################
sub generate_secondary_power {
    $city->{'secondarypower'}={};

    # select a plot
    my $plotlist=$xml_data->{'secondarypower'}->{'plot'};
    $city->{'secondarypower'}->{'plot'} = rand_from_array( $plotlist )->{'content'};

    #select a power and a related subplot.
    my $powerlist=$xml_data->{'secondarypower'}->{'power'} ;
    my $power = rand_from_array(  $powerlist );
    $city->{'secondarypower'}->{'power'} = rand_from_array(  $powerlist )->{'type'};
    if ( &d(100) <= $power->{'subplot_chance'} ){
        $city->{'secondarypower'}->{'subplot'} = rand_from_array(  $power->{'subplot'}  )->{'content'};
    }
}


###############################################################################
#
# set_govt_type - fairly simple; select a type of govt from the list.
#
###############################################################################
sub set_govt_type {
    my $govttypelist=$xml_data->{'govtypes'}->{'govt'} ;
    $city->{'govtype'} = rand_from_array(  $govttypelist  );

    my $descriptorlist=$xml_data->{'govtypes'}->{'descriptor'} ;
    my $descriptor = rand_from_array(  $descriptorlist  );
    $city->{'govtype'}->{'descriptor'}=$descriptor->{'content'};

    # add random element + govtype base approvalmod + descriptor approval + authority mod
    $city->{'govtype'}->{'approvalmod'}    = &d(4)-2 +  $city->{'govtype'}->{'approvalmod'} + $descriptor->{'approvalmod'} +  $city->{'authority'};

    # ensure it falls in the proper range
    $city->{'govtype'}->{'approvalmod'}=max(-5, min(5,  $city->{'govtype'}->{'approvalmod'}   ) );

    $city->{'govtype'}->{'religion'}=&d(4)-2 +  $city->{'govtype'}->{'religion'} ; 

    $city->{'govtype'}->{'mil_mod'}=  $city->{'govtype'}->{'mil_mod'} ; 

}



###############################################################################
#
# Set Laws - Laws have three facets- enforcement, trial and punishment. 
# Select these from arrays.
#
###############################################################################

sub set_laws {
    $city->{'laws'} = {};
    for my $facet (qw( enforcement trial punishment enforcer commoncrime)) {
        my $facetlist=$xml_data->{'laws'}->{$facet}->{'option'};
        $city->{'laws'}->{$facet} = rand_from_array(  $facetlist  )->{'content'};
    }
}



###############################################################################
#
# generate_city_ethics - Intended for morals and order (classic alignment).
#
###############################################################################
sub generate_city_ethics {
    foreach my $mod ( qw/ moral order/ ) {
        $city->{$mod} = &d(100);
        # adjust all modifiers for each race
        for my $race ( @{ $city->{'races'} } ) {
            $city->{$mod} += $race->{$mod};
        }
        # Use min/max to ensure that we fall in the proper ranges when all is said and done        
        $city->{$mod}=max(1, min(100, $city->{$mod} ) );
        # choose a description
        my $description=roll_from_array( $city->{$mod} , $xml_data->{$mod.'alignment'}->{'option'});
        $city->{$mod."description"}=rand_from_array( $description->{'adjective'})->{'content'};
    }
}
###############################################################################
#
# generate_city_beliefs - This includes other scales, such as determining if 
# the city is a trade hub, etc. 
#
###############################################################################
sub generate_city_beliefs {

    # set the baseline random modifier
    foreach my $mod (qw/ magic authority economy education travel tolerance military / ){
        $city->{$mod} =&d(4)-2;
        # adjust all modifiers for each race
        for my $race ( @{ $city->{'races'} } ) {
            $city->{$mod} += $race->{$mod};
        }

        # Use min/max to ensure that we fall in the proper ranges when all is said and done        
        $city->{$mod} = max(-5, min(5, $city->{$mod} ) );
        my $description=roll_from_array( $city->{$mod} , $xml_data->{$mod.'alignment'}->{'option'});
        $city->{$mod."description"}=rand_from_array( $description->{'adjective'})->{'content'};
    }


}

###############################################################################
#
# generate_population_counts - for each race percentage. After getting 
# population counts, recalulate total population, then final percentages.
# note that actual races are not yet associated.
#
###############################################################################
sub generate_pop_counts {
    my $population = $city->{'population'};
    my $newpop     = 0;
    my @races;
    my @newraces;

    # Loop through each race percentage, and get a rough count based
    # on population total
    for my $race ( sort @{ $city->{'races'} } ) {
        $race->{'count'} = ceil( $population * $race->{'percent'} / 100 );
        $newpop += $race->{'count'};
        push @races, $race;
    }

    # Add up all of the rough counts to create a final population total
    $city->{'population'} = $newpop;
    $city->{'races'}      = \@races;

    # Loop through the races a second time, recalulating percentages.
    for my $race ( sort @{ $city->{'races'} } ) {
        $race->{'percent'} = int( $race->{'count'} / $newpop * 1000 ) / 10;
        push @newraces, $race;
    }
    $city->{'races'} = \@newraces;
}


###############################################################################
#
# Assign races. This consists of 
#   * looking at the base population type to gather available base races 
#   * looping through the race percentages and assigning an available race
#   * adding an "off race" if applicable.
#   * adding 1% other    
#
###############################################################################
sub assign_races {
    my $base_pop        = $city->{'base_pop'};
    my @races;


    # Get all of the available race options
    my @available_races = get_races($base_pop);

    # for each race percentage on the city,
    # add assign a race and add it to the list.
    for my $racepercentage ( @{ $city->{'races'} } ) {
        my $newrace = pop(@available_races);
        push @races, add_race_features( $racepercentage, $newrace );
    }


    # If the base_pop has an "off" race, add it.
    if ( $city->{'add_other'} eq 'true' ) {
        my $newrace              = get_other_race($base_pop);
        my $replace_race_id      = &d( scalar @races ) - 1;
        $races[$replace_race_id] = add_race_features( $races[$replace_race_id], $newrace );
    }

    # add the last percent of "others" because mrsassypants didn't grok that
    # things added up to 99% for a reason.
    push @races,add_race_features( {'percent'=>'1'}, get_races('other'));

    for my $race ( @races ) {
        my $roll= &d(10)-5 + $race->{'tolerance'} ;
        my $tolerancetype = roll_from_array( $roll , $xml_data->{'tolerancealignment'}->{'option'} );
        $race->{'tolerancedescription'}= rand_from_array( $tolerancetype->{'adjective'})->{'content'};
    }

    #replace race percentages with full race breakdowns.
    $city->{'races'} = \@races;
}


###############################################################################
#
# add_race_features - copy the features over for a given races. Effectively
# merges percent onto the race.
#
###############################################################################

sub add_race_features {
    my ( $race, $newrace ) = @_;
    $race->{'name'}      = $newrace->{'content'};
    $race->{'order'}     = $newrace->{'order'};
    $race->{'moral'}     = $newrace->{'moral'};
    $race->{'magic'}     = $newrace->{'magic'};
    $race->{'authority'} = $newrace->{'auth'};
    $race->{'economy'}   = $newrace->{'econ'};
    $race->{'education'} = $newrace->{'edu'};
    $race->{'travel'}    = $newrace->{'travel'};
    $race->{'military'}    = $newrace->{'mil'};
    $race->{'tolerance'} = $newrace->{'toler'};
    $race->{'plural'}    = $newrace->{'plural'};
    $race->{'type'}      = $newrace->{'type'};

    if (defined $race->{'dominant'} ){
        $city->{'dominant_race'}  =  $newrace->{'content'};
    }
    return $race;
}



###############################################################################
#
# get races - get the races that match the given population type.
# If the type is mixed, add the race as long as it's not an other race.
#
###############################################################################

sub get_races {
    my ( $type ) = @_;
    my @races;
    for my $race ( @{ $xml_data->{'races'}->{'race'} } ) {
        if (   ($race->{'type'} eq $type)  or   (($type eq 'mixed') and  ($race->{'type'} ne 'other')) ) {
            push @races, $race;
        }
    }
    return shuffle @races;
} 

###############################################################################
#
# get_other_race - get the races that doesn't match the given population type.
# make sure to exclude other.
#
###############################################################################

sub get_other_race {
    my ($type) = @_;
    my @races;
    for my $race ( shuffle @{ $xml_data->{'races'}->{'race'} } ) {
        if ( $race->{'type'} ne $type  and   ($race->{'type'} ne 'other') ) {
            return $race;
        }
    }
} 

###############################################################################
#
# Generate a Population Type, then populate the population type, population 
# density, and a list of unassigned race percentages.
#
###############################################################################
sub generate_pop_type {
    my $poptype     = roll_from_array( &d(100), $xml_data->{'poptypes'}->{'population'} );
    my $popdensity  = rand_from_array( $xml_data->{'popdensity'}->{'option'} );

    $city->{'popdensity'}   = $popdensity;
    $city->{'poptype'}      = $poptype->{'type'};
    $city->{'races'}        = $poptype->{'option'};
}


###############################################################################
#
# set_city_type - Find the type of city by selecting it from the citytype list,
# Then populate the base population, type, description and whether 
# or not it's a mixed city.
#
###############################################################################
sub set_city_type {
    my $citytypelist=$xml_data->{'citytype'}->{'city'};
    my $citytype = roll_from_array( &d(100), $citytypelist );

    $city->{'base_pop'}    = $citytype->{'base_pop'};
    $city->{'type'}        = $citytype->{'type'};
    $city->{'description'} = $citytype->{'content'};
    $city->{'add_other'}   = $citytype->{'add_other'};
}


###############################################################################
#
# set_city_size - Find the size of the city by selecting from the citysize 
# list, then populate the size, gp limit, population, and size modifier.
#
###############################################################################
sub set_city_size {
    my $citysizelist=$xml_data->{'citysize'}->{'city'} ;
    my $citysize = roll_from_array( &d(100), $citysizelist );

    $city->{'size'}          = $citysize->{'size'};
    $city->{'gplimit'}       = $citysize->{'gplimit'};
    $city->{'population'}    = $citysize->{'minpop'} + &d( $citysize->{'maxpop'} - $citysize->{'minpop'} );
    $city->{'size_modifier'} = $citysize->{'size_modifier'};
}

#######################################################################################################################
################                                                                                       ################
################                            These are more generic functions                           ################
################                                                                                       ################
#######################################################################################################################
#######################################################################################################################
#######################################################################################################################
#######################################################################################################################


###############################################################################
#
# set_seed - check the parameters for cityID and set the seed accordingly.
# This is what allows us to return to previously generated hosts.
#
###############################################################################
sub set_seed{
    if (defined $q->param('cityid') and  $q->param('cityid')=~/(\d+)/){
        return $1;
    }else{
        return int rand(1000000);
    }
}


###############################################################################
#
# rand_from_array - select a random item from an array.
#
###############################################################################
sub rand_from_array {
    my ($array) = @_;
    my $index = int( rand( scalar @{ $array} ) );
    return $array->[$index];
}

###############################################################################
#
# roll_from_array - When passed a roll and a list of items, check the
# min and max properties of each and select the one that $roll best fits
# otherwise use the first item.
# 
###############################################################################
sub roll_from_array {
    my ( $roll, $items ) = @_;
    my $selected_item = $items->[0];
    for my $item (@$items) {
        if (defined $item->{'min'} and defined $item->{'max'} ){
            if ( $item->{'min'} <= $roll and $item->{'max'} >= $roll ) {
                $selected_item = $item;
                last;
            }
        }elsif ( defined $item->{'min'}   and ! defined $item->{'max'} ){
            if ( $item->{'min'} <= $roll ) {
                $selected_item = $item;
                last;
            }
        }elsif ( ! defined $item->{'min'} and   defined $item->{'max'} ){
            if ( $item->{'max'} >= $roll ) {
                $selected_item = $item;
                last;
            }
        }elsif ( ! defined $item->{'min'} and !  defined $item->{'max'} ){
                $selected_item = $item;
                last;
        }
    }
    return $selected_item;
}

###############################################################################
#
# d - this serves the function of rolling a dice- a d6, d10, etc.
#
###############################################################################
sub d {
    my ($die) = @_;
    # d as in 1d6
    if ($die =~/^\d+$/){
        return int( rand($die) );
    }elsif ($die=~/^(\d+)d(\d+)$/){
        my $dicecount=$1;
        my $die=$2;
        my $total=0;
        while ($dicecount-- >0){
            $total+=&d($die);
        }
        return $total;
    }else{
        return 1;
    }
}

#####################################################
#
# Parse Object - a horribly named subroutine to parse
# out and randomly select the parts.
#
#####################################################
sub parse_object {
    my ($object)=@_;
    my $newobj= { 'content'=>'' };
    # We currently only care about 4 parts
    foreach my $part (qw/title pre root post trailer/){
        # Make sure that the part exists for this object.
        if(defined $object->{$part}){

            my $newpart;
            # If the object is an array, we're going to shuffle
            # the array and select one of the elements.
            if ( ref($object->{$part}) eq 'ARRAY'){
                # Shuffle the array and pop one element off
                my @parts=shuffle( @{$object->{$part}});
                $newpart=pop(@parts);

            # If the object is a Hash, we presume that there's only one choice
            } elsif ( ref($object->{$part}) eq 'HASH'  and $object->{$part}->{'content'}){
                # rename for easier handling
                $newpart=$object->{$part};
            }

            # make sure the element has content;
            # ignore it if it doesn't.
            if (defined $newpart->{'content'}){
                if (
                        # If no chance is defined, add it to the list.
                        (!defined $object->{$part.'_chance'}) or
                        # If chance is defined, compare it to
                        # the roll, and add it to the list.
                        (defined $object->{$part.'_chance'} and &d(100) <= $object->{$part.'_chance'}) ) {
                    
                    $newobj->{$part}=$newpart->{'content'};
                    if ($part eq 'title'){  
                        $newpart->{'content'}="$newpart->{'content'} " ;
                    }elsif ($part eq 'trailer'){  
                        $newpart->{'content'}=" $newpart->{'content'}" ;
                    }
                    $newobj->{'content'}.= $newpart->{'content'};
                }
            }
        }
    }
    # return the slimmed down version
    return $newobj;
}


